# 动态规划

#### 动态规划









| 题号题目                                                     | 类型                | 难度 | 状态说明                                                     | 状态转移方程                                                 | 链接                                                         |
| :----------------------------------------------------------- | ------------------- | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [509. 斐波那契数](https://www.wolai.com/meafa8eevhQnvZW9mCpTpx "509. 斐波那契数") | 单序列,坐标型       | 简单 | i表示第i个斐波那契数                                         | dp\[i]=dp\[i-1]+dp\[i-2]                                     | [https://leetcode.cn/problems/fibonacci-number/](https://leetcode.cn/problems/fibonacci-number/ "https://leetcode.cn/problems/fibonacci-number/") |
| [70.爬楼梯](https://www.wolai.com/5tkzpwMRkfcuF6LboGPRBR "70.爬楼梯") | 单序列,坐标型       | 简单 | i表示第i级台阶                                               | dp\[i]=dp\[i-1]+dp\[i-2]                                     | [https://leetcode.cn/problems/climbing-stairs/](https://leetcode.cn/problems/climbing-stairs/ "https://leetcode.cn/problems/climbing-stairs/") |
| [746. 使用最小花费爬楼梯](https://www.wolai.com/2TmDF6VRXYwW2esxLwec4s "746. 使用最小花费爬楼梯") | 单序列,坐标型       | 简单 | i表示第i级台阶                                               | dp\[i]=min(dp\[i−1]+cost\[i−1],dp\[i−2]+cost\[i−2])          | [https://leetcode.cn/problems/min-cost-climbing-stairs/](https://leetcode.cn/problems/min-cost-climbing-stairs/ "https://leetcode.cn/problems/min-cost-climbing-stairs/") |
| [264. 丑数 II](https://www.wolai.com/jEm1ky3Fx539xSCMLcQzzL "264. 丑数 II") | 坐标型              | 中等 | dp\[i]表示第i个丑数                                          | dp\[i] = min(dp\[p2] \* 2, dp\[p3] \* 3, dp\[p5] \* 5)       | [https://leetcode.cn/problems/ugly-number-ii/](https://leetcode.cn/problems/ugly-number-ii/ "https://leetcode.cn/problems/ugly-number-ii/") |
| [剑指 Offer 60. n个骰子的点数](https://www.wolai.com/5RP5fwU98TPgyjKX61qYYr "剑指 Offer 60. n个骰子的点数") | 坐标型              | 中等 | dp\[i]\[j]为第i次掷骰子时点数j出现的次数                     | dp\[i]\[j] = sum(dp\[i-1]\[j-k]) k=1\~6 and j-k>=1           |                                                              |
| [剑指 Offer 42. 连续子数组的最大和](https://www.wolai.com/2RT83FSHw2ccUWASkRCsb5 "剑指 Offer 42. 连续子数组的最大和") | 坐标型              | 中等 | dp\[i] 表示以元素 nums\[i] 为结尾的连续子数组最大和          | dp\[i] = max(nums\[i], dp\[i-1] + nums\[i])                  |                                                              |
| [121.买卖股票的最佳时机](https://www.wolai.com/78MVFQPtYwWCCVNBHuWxuw "121.买卖股票的最佳时机") | 单序列,坐标型       | 简单 | dp\[i] 表示第 i 天的最大利润                                 | minprice = min(minprice, prices\[i])&#xA;dp\[i] = max(dp\[i - 1], prices\[i] - minprice) |                                                              |
| [122.买卖股票的最佳时机 II](https://www.wolai.com/5WH9hmvfcXdJFDAChaLG4b "122.买卖股票的最佳时机 II") | 坐标型              | 中等 | dp\[i]\[0] 表示第 i 天交易完后手里没有股票时的最大利润&#xA;dp\[i]\[1] 表示第 i 天交易完后手里持有一支股票时的最大利润 | dp\[i]\[0] = max(dp\[i - 1]\[0], dp\[i - 1]\[1] + prices\[i])&#xA;dp\[i]\[1] = max(dp\[i - 1]\[1], dp\[i - 1]\[0] - prices\[i]) |                                                              |
| [123. 买卖股票的最佳时机 III](https://www.wolai.com/gJw9AixrZt9eZXUvKswLYE "123. 买卖股票的最佳时机 III") | 坐标型              | 困难 | buy1表示第一次购买、sell1表示第一次售卖、buy2表示第二次购买、sell2表示第二次售卖 | buy1 = Math.max(buy1, -prices\[i]);&#xA;sell1 = Math.max(sell1, buy1 + prices\[i]);&#xA;buy2 = Math.max(buy2, sell1 - prices\[i]);&#xA;sell2 = Math.max(sell2, buy2 + prices\[i]); |                                                              |
| [188. 买卖股票的最佳时机 IV](https://www.wolai.com/fFd5eXpKdvNVgishDmauND "188. 买卖股票的最佳时机 IV") | 坐标型              | 困难 | buy\[i]\[j]表示在第i天刚好进行j次交易时 持有股票的最大收益   | buy\[i]\[j] = Math.max(buy\[i - 1]\[j], sell\[i - 1]\[j] - prices\[i]);&#xA;sell\[i]\[j] = Math.max(sell\[i - 1]\[j], buy\[i - 1]\[j - 1] + prices\[i]); |                                                              |
| [309. 最佳买卖股票时机含冷冻期](https://www.wolai.com/negBcLggHie6Tx68NjnGqa "309. 最佳买卖股票时机含冷冻期") | 坐标型              | 中等 | dp\[i]\[0]: 手上持有股票的最大收益&#xA;dp\[i]\[1]: 手上不持有股票，并且处于冷冻期中的累计最大收益&#xA;dp\[i]\[2]: 手上不持有股票，并且不在冷冻期中的累计最大收益 | dp\[i]\[0] = Math.max(dp\[i - 1]\[0], dp\[i - 1]\[2] - prices\[i]);&#xA;dp\[i]\[1] = dp\[i - 1]\[0] + prices\[i];&#xA;dp\[i]\[2] = Math.max(dp\[i - 1]\[1], dp\[i - 1]\[2]); |                                                              |
| [714. 买卖股票的最佳时机含手续费](https://www.wolai.com/o645AjGNJgKcqNMpZ2wbGL "714. 买卖股票的最佳时机含手续费") | 坐标型              | 中等 | dp\[i]\[0] 表示第 i 天交易完后手里没有股票时的最大利润&#xA;dp\[i]\[1] 表示第 i 天交易完后手里持有一支股票时的最大利润 | dp\[i]\[0]=Math.max(dp\[i-1]\[0],dp\[i-1]\[1]+prices\[i]-fee);&#xA;dp\[i]\[1]=Math.max(dp\[i-1]\[1],dp\[i-1]\[0]-prices\[i]); |                                                              |
| [62. 不同路径](https://www.wolai.com/4T28cdfR6XEcxZGySjAby2 "62. 不同路径") | 路径型              | 中等 | dp\[i]\[j]表示到坐标i，j时的不同路径数                       | if(i>0&\&j>0)&#xA;dp\[i]\[j] = dp\[i-1]\[j]+dp\[i]\[j-1];&#xA;else if(i>0) dp\[i]\[j]=dp\[i-1]\[j];&#xA;else if(j>0) dp\[i]\[j]=dp\[i]\[j-1]; |                                                              |
| [63. 不同路径 II](https://www.wolai.com/9Gr4vN2E64EoSDoCchJLJj "63. 不同路径 II") | 路径型              | 中等 | dp\[i]\[j]表示到坐标i，j时的不同路径数                       | if (grid\[i]\[j] != 1) &#xA; f\[i]\[j] = f\[i - 1]\[j] + f\[i]\[j - 1];              &#xA; |                                                              |
| [64. 最小路径和](https://www.wolai.com/ew1e2nA8YcX8AF9rZMkFhj "64. 最小路径和") | 路径型              | 中等 | dp\[i]\[j]表示i，j位置的最小路径                             | dp\[i]\[j]=Math.min(dp\[i-1]\[j],dp\[i]\[j-1])+grid\[i]\[j]; |                                                              |
| [174. 地下城游戏](https://www.wolai.com/56FfM9qtrsMuTDFKUHLFgB "174. 地下城游戏") | 路径型              | 困难 | 从终点往起点反向dp dp\[i]\[j]表示到达i，j位置时最少需要的血量 | dp\[i]\[j] = Math.max(Math.min(dp\[i+1]\[j],dp\[i]\[j+1])-dungeon\[i]\[j],1); |                                                              |
| [329. 矩阵中的最长递增路径](https://www.wolai.com/oMZYU2C1tvniNRaaquxPwU "329. 矩阵中的最长递增路径") | 路径型              | 困难 | i，j表示到达i，j时的最长递增路径                             | dp\[i]\[j] = max(dp\[i]\[j], dp\[nextI]\[nextJ] + 1)&#xA;nextI, nextJ = \[(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] |                                                              |
| [656. 金币路径](https://www.wolai.com/7v11snz7cY9DwbCoN9UZDk "656. 金币路径") | 路径型              | 困难 | dp\[i]表示到达i处需要花费的最少金币（反向）                  | dp\[i] = dp\[j] + coins\[i]                                  |                                                              |
| [198. 打家劫舍](https://www.wolai.com/4QyHmm57V2HzDEBPf7pGh "198. 打家劫舍") | 单序列,路径型       | 中等 | dp\[i]表示到达第i家时获得的最大收益                          | dp\[i]=Math.max(dp\[i-2]+nums\[i],dp\[i-1]);                 |                                                              |
| [213. 打家劫舍 II](https://www.wolai.com/dnwUdpo7BorKVuzV7w4Yi6 "213. 打家劫舍 II") | 路径型              | 中等 | 将区间分为0-n-1、1-n两份对两份分别使用198的方法              | dp\[i]=Math.max(dp\[i-2]+nums\[i],dp\[i-1]);                 |                                                              |
| [276. 栅栏涂色](https://www.wolai.com/o2qyVa1oggJpNm5cLCSUvw "276. 栅栏涂色") | 路径型              | 中等 | dp\[i]表示第i个栅栏的方法 如果与dp\[i-1]不同，则有k-1种方法、如果与dp\[i-1]相同，需要保证i-1与i-2不同i-1就有k-1种方法 同理i也有k-1种解法 | dp\[i] = dp\[i - 1] \* (k - 1) + dp\[i - 2] \* (k - 1) =(dp\[i−2]+dp\[i−1])∗(k−1)&#xA;&#xA; |                                                              |
| [120. 三角形最小路径和](https://www.wolai.com/9cbDqVnqxiWbxcJnuof2ve "120. 三角形最小路径和") | 路径型              | 中等 | f\[i]\[j]f\[i]\[j] 表示从三角形顶部走到位置 (i, j)(i,j) 的最小路径和。 | f\[i]\[j]=min(f\[i−1]\[j−1],f\[i−1]\[j])+c\[i]\[j]           |                                                              |
| [322. 零钱兑换](https://www.wolai.com/sTQ7YNG6XJaY1VkPX3kqbQ "322. 零钱兑换") | 背包型,完全背包     | 中等 | dp\[i]\[j]表示对于前i种硬币，取出amount为j的最少硬币取法（完全背包）可以优化为一维dp\[i]表示对于amount为i的最少取法 | dp\[i]\[j]=Math.min(dp\[i]\[j],dp\[i]\[j-coins\[i-1]]+1);或者采用一维 dp\[i] = Math.min(dp\[i], dp\[i - coin] + 1); |                                                              |
| [518. 零钱兑换 II](https://www.wolai.com/bfbXGTakWYB3vRBEUbu2EX "518. 零钱兑换 II") | 背包型,完全背包     | 中等 | dp\[i]表示对于目标钱数i 有多少种可能                         | dp\[i] += dp\[i - coin];                                     |                                                              |
| [474. 一和零](https://www.wolai.com/i2B8sFBMGsnT21cFaQzQTF "474. 一和零") | 背包型,01背包       | 中等 | 01背包  dp\[i]\[j]表示0的容量为i ，1的容量为j的子集中的最大个数 | dp\[i]\[j]=Math.max(dp\[i]\[j],dp\[i-Zeros]\[j-Ones]+1);     |                                                              |
| [416. 分割等和子集](https://www.wolai.com/7yGsk6gW2AJS4AWkr7TbUz "416. 分割等和子集") | 背包型,01背包       | 中等 | 01背包 dp\[i]表示目标和为i时是否可以分割成功                 | dp\[i]=dp\[i]\|\|dp\[i-num];                                 |                                                              |
| [1049. 最后一块石头的重量 II](https://www.wolai.com/agPEXT2YvWco4XtsUwuFyj "1049. 最后一块石头的重量 II") | 背包型,01背包       | 中等 | 01背包 背包容量为sum/2 找到最大值  答案就为 sum-2\*dp\[n] dp\[i]表示容量为i时的最小答案 | dp\[i]=Math.max(dp\[i],dp\[i-stone]+stone);                  |                                                              |
| [494. 目标和](https://www.wolai.com/7ZAtEMtvCnsdJZZyiPsaGw "494. 目标和") | 背包型,01背包       | 中等 | 将加数拆分为两块 一块为加数写作a 一块为减数为b 则最终target应该等于a-b=target  而a+b=sum两式相加得a=（S+sum）/2剩下的一半即为减数 所以题目就变成求解 背包容量为a的种类数 | dp\[i]+=dp\[i-num];                                          |                                                              |
| [377. 组合总和 Ⅳ](https://www.wolai.com/mAnXjVKs6NAXs3WWSzdaw7 "377. 组合总和 Ⅳ") | 背包型,01背包       | 中等 | 同494                                                        | dp\[i]+=dp\[i-num];                                          |                                                              |
| [115. 不同的子序列](https://www.wolai.com/j6qCYjL9pmWpa52DaTzUH4 "115. 不同的子序列") | 双序列              | 困难 | dp\[i]\[j]表示在target的前j个字符在s的前i个字符中出现的次数  | if(s.charAt(i-1)==t.charAt(j-1))&#xA;dp\[i]\[j]=dp\[i-1]\[j]+dp\[i-1]\[j-1];&#xA; else&#xA;dp\[i]\[j]=dp\[i-1]\[j]; |                                                              |
| [91. 解码方法](https://www.wolai.com/3ipEmbarEp7EdPHK1UxWCt "91. 解码方法") | 单序列              | 中等 | 通过dfs recursive方式记录搜索结果 memo\[i]表示i...length的解码方法个数 | memo\[i]=dfs(s,i+1,memo)+dfs(s,i+2,memo);                    |                                                              |
| [139. 单词拆分](https://www.wolai.com/gATXamtVwk2KaGvLyc5W9X "139. 单词拆分") | 单序列              | 中等 | dp\[i]记录索引到i时字典是否包含该单词                        | dfs或iterative way                                           |                                                              |
| [140. 单词拆分 II](https://www.wolai.com/jqqsoac3k6sYcbr8u8cVo7 "140. 单词拆分 II") | 单序列              | 困难 | 同上 需要记录答案                                            |                                                              |                                                              |
| [53. 最大子数组和](https://www.wolai.com/razhWimkHjBhsxMteuExjg "53. 最大子数组和") | 单序列              | 简单 | dp\[i]表示到达i位置时前i个元素的最大子数组和为多少           | dp\[i]=max(dp\[i-1],dp\[i]+num\[i])                          |                                                              |
| [152. 乘积最大子数组](https://www.wolai.com/iGiYbjfp7caFuiioSnS1hx "152. 乘积最大子数组") | 单序列              | 中等 | 维护一个maxdp和一个mindp 如果当前数大于0则max为nums\*max     | if(nums\[i]>0)          max\[i]=Math.max(nums\[i],nums\[i]*max\[i-1]);&#xA;min\[i]=Math.min(nums\[i],nums\[i]* min\[i-1]);&#xA;else{&#xA;max\[i]=Math.max(nums\[i],nums\[i]*min\[i-1]);&#xA;min\[i]=Math.min(nums\[i],nums\[i]* max\[i-1]);&#xA;} |                                                              |
| [300. 最长递增子序列](https://www.wolai.com/jVFMw5XbH6HCy3kEX2kDXX "300. 最长递增子序列") | 单序列              | 中等 | 维护一个单调栈 有比末尾数字大的数进来时 在dp中通过二分法寻找插入位置 最后返回size就是答案 dp\[i]为构造的答案 |                                                              |                                                              |
| [1713. 得到子序列的最少操作次数](https://www.wolai.com/tiAJTHUBrr2RWzJqqEJ57K "1713. 得到子序列的最少操作次数") | 单序列              | 困难 | 利用300题解 计算target序列的下标的最长递增子序列数 target-res即为 | 同300                                                        |                                                              |
| [97. 交错字符串](https://www.wolai.com/uahGXKduDVnW79cF9dsaEM "97. 交错字符串") | 双序列              | 中等 | dp\[i]\[j]表示s1的前i个和s2的前j个字符能否组成s3的前i+j个字符 如果能则true | dp\[i]\[j]=(s3.charAt(i+j-1)==s1.charAt(i-1)&\&dp\[i-1]\[j])\|\|(s3.charAt(i+j-1)==s2.charAt(j-1)&\&dp\[i]\[j-1]); |                                                              |
| [72. 编辑距离](https://www.wolai.com/8V6pYUDe8obGMTAbM7MhiU "72. 编辑距离") | 双序列              | 困难 | dp\[i]\[j]表示a的前i个和b的前j个之间的编辑距离   A后有三种可能 a的char与b相等 则直接拿i-1，j-1即可， a删除一个与b相等，a替换一个与b相等，a插入一个与b相等 | if(word1.charAt(i-1)==word2.charAt(j-1))&#xA;dp\[i]\[j]=dp\[i-1]\[j-1];&#xA; else&#xA;dp\[i]\[j]=Math.min(Math.min(dp\[i-1]\[j]+1,dp\[i]\[j-1]+1),dp\[i-1]\[j-1]+1); |                                                              |
| [1143. 最长公共子序列 lcs](https://www.wolai.com/j6jn8NdbJPfAmCaGVd1fvD "1143. 最长公共子序列 lcs") | 双序列              | 中等 | dp\[i]\[j]表示s1的前i个字符串与s2的前j个字符组成的最长公共子序列 | if(word1.charAt(i-1)==word2.charAt(j-1))&#xA;dp\[i]\[j]=1+dp\[i-1]\[j-1];&#xA;else&#xA;dp\[i]\[j]=Math.max(dp\[i-1]\[j]+1,dp\[i]\[j-1]+1); |                                                              |
| [1312. 让字符串成为回文串的最少插入次数](https://www.wolai.com/hPtUzccBqAsjv4unNZioag "1312. 让字符串成为回文串的最少插入次数") | 双序列              | 困难 | lcs变形 将字符串翻转 再找翻转的字符串与原来的lcs 答案为length-lcs | 同1143                                                       |                                                              |
| [516. 最长回文子序列](https://www.wolai.com/wUzjHPWL7enJpKggbx4AVr "516. 最长回文子序列") | 双序列,区间型       | 中等 | lcs 直接返回reverse后的字符串                                | 同1143                                                       |                                                              |
| [1216. 验证回文字符串 III](https://www.wolai.com/sDoaeAX2UwKwF7TY4hc3b7 "1216. 验证回文字符串 III") | 双序列,区间型       | 困难 | lcs 判断s.length-lcs是否<=k                                  | 同1143                                                       |                                                              |
| [5. 最长回文子串](https://www.wolai.com/7s4LWtcRf7uJCiNiUTRNJS "5. 最长回文子串") | 区间型              | 中等 | dp\[i]\[j]表示字符串在i...j范围内是否为回文串  如果chari==charj 则看内部是否是回文串 i+1到j-1是否是回文串 | if(s.charAt(i)==s.charAt(j)&&((j-i)<=2\|\|dp\[i+1]\[j-1]))&#xA;dp\[i]\[j]=true;&#xA; |                                                              |
| [312. 戳气球](https://www.wolai.com/9ou6T442YY5cGKxCBhQkBH "312. 戳气球") | 区间型              | 困难 | dp\[i]\[j]表示在i...j范围内拿到的最多硬币数                  | dfs+memo                                                      left = dfs(start,i-1,nums,dp);&#xA;int right = dfs(i+1,end,nums,dp);&#xA;int cur = get(nums,i)*get(nums,start-1)* get(nums,end+1);&#xA;max = Math.max(max,cur+left+right); |                                                              |
| [1039. 多边形三角剖分的最低得分](https://www.wolai.com/ksFTQJPnfmRMb9be7xbLSP "1039. 多边形三角剖分的最低得分") | 区间型              | 中等 | 同312 需要注意的是多边形至少要有三条边                       |                                                              |                                                              |
| [221. 最大正方形](https://www.wolai.com/6sBcrBFLwt6t3CqsE12Jir "221. 最大正方形") | 坐标型              | 中等 | dp\[i]\[j]表明以i，j为右下角的最大正方形的面积               | dp\[i]\[j]=Math.min(Math.min(dp\[i-1]\[j],dp\[i]\[j-1]),dp\[i-1]\[j-1])+1; |                                                              |
| [294. 翻转游戏 II](https://www.wolai.com/9cDKTN33nZi61bexaQk36x "294. 翻转游戏 II") | 博弈型              | 中等 | dfs+memo                                                     |                                                              |                                                              |
| [292. Nim 游戏](https://www.wolai.com/gWEZ8RBd4gciA2XCDQ3v1T "292. Nim 游戏") | 博弈型              | 中等 | return n%4!=0;                                               |                                                              |                                                              |
| [877. 石子游戏](https://www.wolai.com/kWZAxvwUtfo7wgpWfUmTBs "877. 石子游戏") | 博弈型              | 中等 | memo+dfs                                                     | memo\[i]\[j]= Math.max(nums\[i]-dfs(nums,i+1,j,memo),nums\[j]-dfs(nums,i,j-1,memo)); |                                                              |
| [376. 摆动序列](https://www.wolai.com/c2RLoGSk1ARzUYvdkRAdxW "376. 摆动序列") |                     | 中等 | 贪心 或 dp 变一维                                            | if (nums\[i] > nums\[i - 1])&#xA;            up = down + 1;&#xA;        else if (nums\[i] < nums\[i - 1])&#xA;            down = up + 1; |                                                              |
| [487. 最大连续1的个数 II](https://www.wolai.com/j4NNNWS33ovKCs6YLUXXN3 "487. 最大连续1的个数 II") | 单序列,行使权力     | 中等 | dp\[i]\[0]表示以当前元素结尾 没有行使翻转权利的最长连续 1  dp\[i]\[1]为行使权利后的结果 | if(nums\[i]==1){&#xA;                dp\[i]\[0]=dp\[i-1]\[0]+1;&#xA;                dp\[i]\[1]=dp\[i-1]\[1]+1;&#xA;            }else{&#xA;                dp\[i]\[0]=0;&#xA;                dp\[i]\[1]=dp\[i-1]\[0]+1;&#xA;            } |                                                              |
| [1186. 删除一次得到子数组最大和](https://www.wolai.com/bZ5ji7KpYJQUQivDq8md7m "1186. 删除一次得到子数组最大和") | 单序列,行使权力     | 中等 | dp\[i]\[0]表示以当前元素结尾 没有行使删除权利的最长连续 1  dp\[i]\[1]为行使删除权利后的结果 | dp\[i]\[0]=Math.max(dp\[i-1]\[0]+arr\[i],arr\[i]);&#xA;            dp\[i]\[1]=Math.max(dp\[i-1]\[0],dp\[i-1]\[1]+arr\[i]); |                                                              |
| [1092. 最短公共超序列](https://www.wolai.com/sRnkdcRnynoqt8D5t1dqMm "1092. 最短公共超序列") | 双序列              | 困难 | LCS 再对dp结果进行处理拿到答案序列                           | 同LCS                                                        |                                                              |
| [1105. 填充书架](https://www.wolai.com/tC99mTHVjW7wNVgd8C2Zn4 "1105. 填充书架") | 单序列,时间序列加强 | 中等 | i表示以第i本书作为上一层的最后一本书的最小高度               | levelWidth+=books\[j-1]\[0];&#xA;if(levelWidth>shelfWidth) break;        levelMaxHeight=Math.max(levelMaxHeight,books\[j-1]\[1]);&#xA;dp\[i]=Math.min(dp\[i],dp\[j-1]+levelMaxHeight); |                                                              |
| [1278. 分割回文串 III](https://www.wolai.com/92ckzocMy1n4B71bLutmXp "1278. 分割回文串 III") | 区间型              | 困难 | dp\[i]\[j]表示前i个字符分割为k个区间需要改动的最小字符个数   对于前i个字符来说 分成的第k个区间取决于第k-1个区间再加上count最后一个区间的次数  在k-1，i的区间内依次遍历即可 | for(int i=0;i<=n;i++)&#xA;for(int j=1;j<=Math.min(i,k);j++){&#xA;if(j==1) dp\[i]\[j]=count(s.substring(0,i));&#xA;for(int m=i-1;m>=j-1;m--){&#xA;dp\[i]\[j]=Math.min(dp\[i]\[j],dp\[m]\[j-1]+count(s.substring(m,i))); |                                                              |
| [813. 最大平均值和的分组](https://www.wolai.com/k1KbFzdVUxPpRcice4tkA8 "813. 最大平均值和的分组") | 区间型              | 中等 | 类似1278 需要初始化dp数组                                    |                                                              |                                                              |
| [410. 分割数组的最大值](https://www.wolai.com/8Twtd8Dun9KcL9oXBQTBhc "410. 分割数组的最大值") | 区间型              | 困难 | 类似1278 本题可以采用二分猜答案                              |                                                              |                                                              |

[坐标型动态规划](https://www.wolai.com/t3zbqB3XRM8iM1qshU9dUh "坐标型动态规划")
