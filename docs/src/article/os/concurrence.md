---
lang: zh-CN
title: å¹¶å‘ç¨‹åº
description: æ“ä½œç³»ç»ŸåŸºç¡€æ¦‚å¿µ
category: 
 - Linux
tag:
 - OS
---

::: tip å¹¶å‘æ¨¡å—

å¤šå¤„ç†å™¨ç¼–ç¨‹

ç†è§£å¹¶å‘ç¨‹åºæ‰§è¡Œ

å¹¶å‘æ§åˆ¶

å¹¶å‘ç¼–ç¨‹åŠå¯¹Bugåº”å¯¹

:::

::: note ä»€ä¹ˆæ˜¯å¹¶å‘(Concurrent)

Concurrent: existing, happening, or done ***at the same time*.**

In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome. (Wikipedia)

:::

å¦‚æœä½¿ç”¨çŠ¶æ€æœºçš„è§†è§’æŸ¥çœ‹å¹¶å‘ç¨‹åºï¼Œå¹¶å‘çš„ç¨‹åºå®é™…æ˜¯ä¸€ä¸ªå…±äº«å†…å­˜çš„å¤šä¸ªæ‰§è¡Œæµ

å…±äº«å†…å­˜çš„å¤šä¸ªæ‰§è¡Œæµ

- æ‰§è¡Œæµæ‹¥æœ‰ç‹¬ç«‹çš„å †æ ˆ/å¯„å­˜å™¨
- å…±äº«å…¨éƒ¨çš„å†…å­˜ (æŒ‡é’ˆå¯ä»¥äº’ç›¸å¼•ç”¨)

å¤šä¸ªæ‰§è¡Œæµä¼šå¸¦æ¥æ–¹ä¾¿ï¼ŒåŒæ—¶ä¹Ÿæ‰“å¼€äº†æ½˜å¤šæ‹‰çš„é­”ç›’

::: note å¹¶å‘ç¨‹åºå¸¦æ¥çš„é—®é¢˜

åŸå­æ€§ç¼ºå¤±

é¡ºåºæ€§ç¼ºå¤±

å¯è§æ€§ç¼ºå¤±

:::

## å¤šå¤„ç†å™¨ç¼–ç¨‹

### **åŸå­æ€§**

åŸå­æ€§ï¼šä¸€æ®µä»£ç æ‰§è¡Œ (ä¾‹å¦‚ `pay()`) ç‹¬å æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿ

- å•å¤„ç†å™¨å¤šçº¿ç¨‹
  - çº¿ç¨‹åœ¨è¿è¡Œæ—¶å¯èƒ½è¢«ä¸­æ–­ï¼Œåˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œ
- å¤šå¤„ç†å™¨å¤šçº¿ç¨‹
  - çº¿ç¨‹æ ¹æœ¬å°±æ˜¯å¹¶è¡Œæ‰§è¡Œçš„

åœ¨å¤šå¤„ç†å™¨æ—¶ä»£ï¼Œç¨‹åºçš„åŸå­æ€§æ— æ³•è¢«ä¿è¯ã€‚æ­¤æ—¶éœ€è¦ä½¿ç”¨å…¶ä»–çš„æ–¹å¼æ¥ä¿è¯åœ¨å¹¶å‘çŠ¶æ€ä¸‹çš„ç¨‹åºçš„åŸå­æ€§ã€‚

é‚£ä¹ˆå¦‚ä½•å®ç°å¹¶å‘ç¨‹åºçš„åŸå­æ€§å‘¢ï¼Ÿ

- `lock(&lk)`
- `unlock(&lk)`
  - å®ç°ä¸´ç•ŒåŒº (critical section) ä¹‹é—´çš„ç»å¯¹ä¸²è¡ŒåŒ–
  - ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†ä¾ç„¶å¯ä»¥å¹¶è¡Œæ‰§è¡Œ

99% çš„å¹¶å‘é—®é¢˜éƒ½å¯ä»¥ç”¨ä¸€ä¸ªé˜Ÿåˆ—è§£å†³

- æŠŠå¤§ä»»åŠ¡åˆ‡åˆ†æˆå¯ä»¥å¹¶è¡Œçš„å°ä»»åŠ¡
- worker thread å»é”ä¿æŠ¤çš„é˜Ÿåˆ—é‡Œå–ä»»åŠ¡
- é™¤å»ä¸å¯å¹¶è¡Œçš„éƒ¨åˆ†ï¼Œå‰©ä¸‹çš„éƒ¨åˆ†å¯ä»¥è·å¾—çº¿æ€§çš„åŠ é€Ÿ



### **é¡ºåºæ€§**

::: note ç¼–è¯‘å™¨çš„ä¼˜åŒ–

ç¼–è¯‘å™¨å¯¹å†…å­˜è®¿é—® â€œeventually consistentâ€ çš„å¤„ç†å¯¼è‡´å…±äº«å†…å­˜ä½œä¸ºçº¿ç¨‹åŒæ­¥å·¥å…·çš„å¤±æ•ˆã€‚

:::

åœ¨Cç¨‹åºè¢«ç¼–è¯‘æˆæ±‡ç¼–ç çš„è¿‡ç¨‹é‡Œï¼Œå¹¶ä¸ä¼šä¿è¯ç¨‹åºæ‰§è¡Œçš„é¡ºåºæ€§ã€‚

å¦ä¸€æ–¹é¢ï¼ŒCPUä¹Ÿæ˜¯ç¼–è¯‘å™¨ï¼Œä¼šå¯¹æ±‡ç¼–ç è¿›è¡Œè¿›ä¸€æ­¥çš„ä¼˜åŒ–ã€‚è¿™ä¹Ÿä¼šå¯¼è‡´ä»£ç é¡ºåºæ€§çš„é”™è¯¯ã€‚

å¦‚ä½•ä¿è¯é¡ºåºæ€§ï¼Ÿ

å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å†…è”æ±‡ç¼–è¯­å¥å®ç°å†…å­˜å±éšœ

```c
asm volatile ("" ::: "memory");
```

__volatile__å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œä¸¥ç¦å°†æ­¤å¤„çš„æ±‡ç¼–è¯­å¥ä¸å…¶å®ƒçš„è¯­å¥é‡ç»„åˆä¼˜åŒ–ã€‚å³ï¼šåŸåŸæœ¬æœ¬æŒ‰åŸæ¥çš„æ ·å­å¤„ç†è¿™è¿™é‡Œçš„æ±‡ç¼–ã€‚
**memory**å¼ºåˆ¶ gcc ç¼–è¯‘å™¨å‡è®¾ RAM æ‰€æœ‰å†…å­˜å•å…ƒå‡è¢«æ±‡ç¼–æŒ‡ä»¤ä¿®æ”¹ï¼Œè¿™æ · cpu ä¸­çš„ registers å’Œ cache ä¸­å·²ç¼“å­˜çš„å†…å­˜å•å…ƒä¸­çš„æ•°æ®å°†ä½œåºŸã€‚**cpu å°†ä¸å¾—ä¸åœ¨éœ€è¦çš„æ—¶å€™é‡æ–°è¯»å–å†…å­˜ä¸­çš„æ•°æ®ã€‚**è¿™å°±é˜»æ­¢äº† cpu åˆå°† registers, cache ä¸­çš„æ•°æ®ç”¨äºå»ä¼˜åŒ–æŒ‡ä»¤ï¼Œè€Œé¿å…å»è®¿é—®å†…å­˜ã€‚
""::: è¡¨ç¤ºè¿™æ˜¯ä¸ªç©ºæŒ‡ä»¤ã€‚barrier() ä¸ç”¨åœ¨æ­¤æ’å…¥ä¸€æ¡ä¸²è¡ŒåŒ–æ±‡ç¼–æŒ‡ä»¤ã€‚åœ¨åæ–‡å°†è®¨è®ºä»€ä¹ˆå«ä¸²è¡ŒåŒ–æŒ‡ä»¤ã€‚

é‚£ä¹ˆè¿™å¥è¯æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå®ƒåªæ˜¯æ’å…¥äº†ä¸€ä¸ªç©ºæŒ‡ä»¤""ï¼Œä»€ä¹ˆä¹Ÿæ²¡åšã€‚å…¶å®ä¸ç„¶ï¼Œè¿™å¥è¯çš„å…³é”®åœ¨æœ€åçš„"memory" clobberï¼Œå®ƒå‘Šè¯‰ç¼–è¯‘å™¨ï¼šè¿™æ¡æŒ‡ä»¤ï¼ˆå…¶å®æ˜¯ç©ºçš„ï¼‰å¯èƒ½ä¼šè¯»å–ä»»ä½•å†…å­˜åœ°å€ï¼Œä¹Ÿå¯èƒ½ä¼šæ”¹å†™ä»»ä½•å†…å­˜åœ°å€ã€‚é‚£ä¹ˆç¼–è¯‘å™¨ä¼šå˜å¾—ä¿å®ˆèµ·æ¥ï¼Œå®ƒä¼šé˜²æ­¢è¿™æ¡fenceå‘½ä»¤ä¸Šæ–¹çš„å†…å­˜è®¿é—®æ“ä½œç§»åˆ°ä¸‹æ–¹ï¼ŒåŒæ—¶é˜²æ­¢ä¸‹æ–¹çš„æ“ä½œç§»åˆ°ä¸Šé¢ï¼Œä¹Ÿå°±æ˜¯é˜²æ­¢äº†ä¹±åºï¼Œæ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœã€‚

ä½†è¿™è¿˜æ²¡å®Œï¼Œè¿™æ¡å‘½ä»¤è¿˜æœ‰å¦å¤–ä¸€ä¸ªå‰¯ä½œç”¨ï¼šå®ƒä¼šè®©ç¼–è¯‘å™¨æŠŠæ‰€æœ‰ç¼“å­˜åœ¨å¯„å­˜å™¨ä¸­çš„å†…å­˜å˜é‡flushåˆ°å†…å­˜ä¸­ï¼Œç„¶åé‡æ–°ä»å†…å­˜ä¸­è¯»å–è¿™äº›å€¼ã€‚è¿™å¹¶ä¸ä¸€å®šæ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼Œæ¯”å¦‚æœ‰äº›å˜é‡åªåœ¨å½“å‰çº¿ç¨‹ä¸­ä½¿ç”¨ï¼Œç•™åœ¨å¯„å­˜å™¨ä¸­å¾ˆå¥½ï¼Œå¤šäº†ä¸€å¯¹å†™/è¯»å†…å­˜æ“ä½œæ˜¯ä¸å¿…è¦çš„å¼€é”€ã€‚

åŒæ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨ mfence æ±‡ç¼–å‘½ä»¤å®ç°å†…å­˜çš„å±éšœ

```c
asm volatile ("mfence" ::: "memory");
```

::: note mfence æ‰‹å†Œ

[mfence](https://www.felixcloutier.com/x86/mfence.html)

[mfence å’Œ asm volatile ("" ::: "memory"); åŒºåˆ«](https://stackoverflow.com/questions/12183311/difference-in-mfence-and-asm-volatile-memory)

:::

### å¯è§æ€§

ç°ä»£çš„å¤„ç†å™¨æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåŠ¨æ€çš„å¤„ç†å™¨

::: note ç°ä»£å¤„ç†å™¨ä¹Ÿæ˜¯åªä¿è¯æœ€ç»ˆä¸€è‡´æ€§

æ»¡è¶³å•å¤„ç†å™¨ eventual memory consistency çš„æ‰§è¡Œï¼Œåœ¨å¤šå¤„ç†å™¨ä¸Šå¯èƒ½æ— æ³•åºåˆ—åŒ–ï¼

[å†…å­˜ç³»ç»Ÿæ¨¡å‹](https://research.swtch.com/hwmm)

:::

å¦‚ä½•ä¿è¯é¡ºåºæ€§

å¯ä»¥é€šè¿‡å…³é”®å­—

```c
__sync_synchronize()
RTFM 
```

[syc æ‰‹å†Œ](https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html)

## å¹¶å‘ç¼–ç¨‹æ§åˆ¶

### äº’æ–¥

::: note äº’æ–¥ç®—æ³•çš„å›°éš¾ç‚¹

å®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼šä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜

- load (ç¯é¡¾å››å‘¨) çš„æ—¶å€™ä¸èƒ½å†™ï¼Œåªèƒ½ â€œçœ‹ä¸€çœ¼å°±æŠŠçœ¼ç›é—­ä¸Šâ€
  - çœ‹åˆ°çš„ä¸œè¥¿é©¬ä¸Šå°±è¿‡æ—¶äº†
- store (æ”¹å˜ç‰©ç†ä¸–ç•ŒçŠ¶æ€) çš„æ—¶å€™ä¸èƒ½è¯»ï¼Œåªèƒ½ â€œé—­ç€çœ¼ç›åŠ¨æ‰‹â€
  - ä¹Ÿä¸çŸ¥é“æŠŠä»€ä¹ˆæ”¹æˆäº†ä»€ä¹ˆ

:::

> Petersonç®—æ³•
>
> 
>
> 

å¦‚æœè½¯ä»¶æ— æ³•è§£å†³é—®é¢˜ï¼Œç¡¬ä»¶å¯ä»¥ç”¨ä¸€æ¡æŒ‡ä»¤æ¥è§£å†³

ç¡¬ä»¶èƒ½ä¸ºæˆ‘ä»¬æä¾›ä¸€æ¡ â€œç¬é—´å®Œæˆâ€ çš„è¯» + å†™æŒ‡ä»¤

åœ¨Intel 80486æŒ‡ä»¤é›†ä¸­ å¢åŠ äº†LockæŒ‡ä»¤

Lockçš„ä½œç”¨ä¸ºï¼Œåœ¨CPUæ‰§è¡Œåˆ°å¸¦æœ‰LockæŒ‡ä»¤çš„æ—¶å€™ï¼Œä¼šå°†å†…å­˜å…ˆä¸Šé”ï¼ˆæ­¤æ—¶å…¶ä»–CPUæ— æ³•è¯»å†™å†…å­˜ï¼‰éšååœ¨æ‰§è¡Œæ“ä½œã€‚

![80486 CPUå†…å­˜æ¨¡å‹](\os\CPU80486.png)

```c
int xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}
```

è¿™æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œæ˜¯åœ¨ç¡¬ä»¶å±‚é¢ä¸Šäº†ä¸€æŠŠæ€»çº¿é”ï¼Œç”±æ€»çº¿å†³å®šè°æ›´å…ˆè¿è¡Œã€‚

ç„¶è€Œä»Šå¤©çš„CPUæ‹¥æœ‰å¤šä¸ªç¼“å­˜(L1ã€L2ã€L3)

![CPU Cacheæ¨¡å‹](\os\CPU80486cache.png)

è¿™æ„å‘³ç€ï¼Œå¦‚æœéœ€è¦ç»™Memoryä¸­çš„æŸä¸ªå€¼ä¸Šé”ï¼Œåˆ™éœ€è¦å°†å…¶ä»–CPUçš„Cacheä¸­çš„è¿™ä¸ªå€¼ç»™åˆ æ‰ï¼Œè¿™å¢åŠ äº†å¾ˆå¤šæ€§èƒ½æŸè€—ã€‚

**æ€è€ƒä¸€ä¸‹ï¼šæˆ‘ä»¬å¯¹åŸå­æ“ä½œçš„ä¸»è¦éœ€æ±‚**

è€ƒè™‘å¸¸è§çš„åŸå­æ“ä½œï¼š

- atomic test-and-set
  - `reg = load(x); if (reg == XX) { store(x, YY); }`
- lock xchg
  - `reg = load(x); store(x, XX);`
- lock add
  - `t = load(x); t++; store(x, t);`

å®ƒä»¬çš„æœ¬è´¨éƒ½æ˜¯ï¼š

1. load
2. exec (å¤„ç†å™¨æœ¬åœ°å¯„å­˜å™¨çš„è¿ç®—)
3. store

é€šè¿‡ç¡¬ä»¶æ¥è§£å†³è¿™ä¸ªé—®é¢˜

#### Load-Reserved/Store-Conditional (LR/SC)

LR: åœ¨å†…å­˜ä¸Šæ ‡è®° reserved (ç›¯ä¸Šä½ äº†)ï¼Œä¸­æ–­ã€å…¶ä»–å¤„ç†å™¨å†™å…¥éƒ½ä¼šå¯¼è‡´æ ‡è®°æ¶ˆé™¤

```
lr.w rd, (rs1)
  rd = M[rs1]
  reserve M[rs1]
```

------

SC: å¦‚æœ â€œç›¯ä¸Šâ€ æœªè¢«è§£é™¤ï¼Œåˆ™å†™å…¥

```
sc.w rd, rs2, (rs1)
  if still reserved:
    M[rs1] = rs2
    rd = 0
  else:
    rd = nonzero
```

ä»ç¡¬ä»¶ä¸Šå®ç°CASæŒ‡ä»¤

#### Compare-and-Swap çš„ LR/SC å®ç°

```
int cas(int *addr, int cmp_val, int new_val) {
  int old_val = *addr;
  if (old_val == cmp_val) {
    *addr = new_val; return 0;
  } else { return 1; }
}
cas:
  lr.w  t0, (a0)       # Load original value.
  bne   t0, a1, fail   # Doesnâ€™t match, so fail.
  sc.w  t0, a2, (a0)   # Try to update.
  bnez  t0, cas        # Retry if store-conditional failed.
  li a0, 0             # Set return to success.
  jr ra                # Return.
fail:
  li a0, 1             # Set return to failure.
  jr ra                # Return
```

è¿™å°±æ˜¯ä¸€ä¸ªè‡ªæ—‹é”ã€‚

::: note LR/SCçš„ç¡¬ä»¶å®ç°

[RISCV-BOOM](https://github.com/riscv-boom/riscv-boom)

[LR SC](https://github.com/riscv-boom/riscv-boom/blob/master/src/main/scala/lsu/dcache.scala#L655)

:::

::: tip è‡ªæ—‹é”ç¼ºé™·

è‡ªæ—‹é”ä¹Ÿä¼šé¢ä¸´ä¸€å®šçš„ç¼ºé™·

- è‡ªæ—‹ (å…±äº«å˜é‡) ä¼šè§¦å‘å¤„ç†å™¨é—´çš„ç¼“å­˜åŒæ­¥ï¼Œå»¶è¿Ÿå¢åŠ 

- é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬
- äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½

- è·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹ å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»
  - æ“ä½œç³»ç»Ÿä¸ â€œæ„ŸçŸ¥â€ çº¿ç¨‹åœ¨åšä»€ä¹ˆ (ä½†ä¸ºä»€ä¹ˆä¸èƒ½å‘¢ï¼Ÿ)
- å®ç° 100% çš„èµ„æºæµªè´¹

:::

è‡ªæ—‹é”æµªè´¹çš„ä¾‹å­

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
spinlock_t lock = SPIN_INIT();

long n, sum = 0;

void Tsum() {
  for (int i = 0; i < n; i++) {
    spin_lock(&lock);
    sum++;
    spin_unlock(&lock);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  int nthread = atoi(argv[1]);
  n = N / nthread;
  for (int i = 0; i < nthread; i++) {
    create(Tsum);
  }
  join();
  assert(sum == n * nthread);
}
```

æ‰§è¡Œä¸Šé¢çš„ä»£ç ï¼Œå‘ç°ä¸€ä¸ªçº¿ç¨‹æ—¶åªéœ€100ms è€Œå¦‚æœå¢åŠ å¤šä¸ªçº¿ç¨‹è¿è¡Œæ—¶ï¼Œæ—¶é—´ä¸å‡åå¢ï¼Œè¿™å°±æ˜¯å› ä¸ºè‡ªæ—‹é”é¢ä¸´çš„é—®é¢˜ã€‚



::: note è‡ªæ—‹é”ä½¿ç”¨åœºæ™¯

**ä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µ**

**æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢**ï¼ˆæŒæœ‰é” ä½†è¢«åˆ‡æ¢å‡ºå» å¯¼è‡´å…¶ä»–ä¸€ç›´åœ¨ç­‰ï¼Œä½†æ“ä½œç³»ç»Ÿä¸ä¼šå…è®¸ç¨‹åºå®ç°è¿™ä¸€ç‚¹ï¼‰

æ•…ä½¿ç”¨åœºæ™¯ä¸»è¦åœ¨ 

- æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å 
  - ä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”
- (å¦‚æœæ˜¯è™šæ‹Ÿæœºå‘¢...ğŸ˜‚)
  - PAUSE æŒ‡ä»¤ä¼šè§¦å‘ VM Exit
- ä½†ä¾æ—§å¾ˆéš¾åšå¥½

:::

é‚£ä¹ˆè¯¥å¦‚ä½•å®ç°é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥å‘¢

â€œè®©â€ ä¸æ˜¯ C è¯­è¨€ä»£ç å¯ä»¥åšåˆ°çš„ (C ä»£ç åªèƒ½è®¡ç®—)

- æŠŠé”çš„å®ç°æ”¾åˆ°æ“ä½œç³»ç»Ÿé‡Œå°±å¥½å•¦ï¼

  - ```
    syscall(SYSCALL_lock, &lk);
    ```

    - è¯•å›¾è·å¾— `lk`ï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹

  - ```
    syscall(SYSCALL_unlock, &lk);
    ```

    - é‡Šæ”¾ `lk`ï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’



æ“ä½œç³»ç»Ÿ = æ›´è¡£å®¤ç®¡ç†å‘˜

- å…ˆåˆ°çš„äºº (çº¿ç¨‹)
  - æˆåŠŸè·å¾—æ‰‹ç¯ï¼Œè¿›å…¥æ¸¸æ³³é¦†
  - `*lk = ğŸ”’`ï¼Œç³»ç»Ÿè°ƒç”¨ç›´æ¥è¿”å›
- ååˆ°çš„äºº (çº¿ç¨‹)
  - ä¸èƒ½è¿›å…¥æ¸¸æ³³é¦†ï¼Œæ’é˜Ÿç­‰å¾…
  - çº¿ç¨‹æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ‰§è¡Œçº¿ç¨‹åˆ‡æ¢ (yield)
- æ´—å®Œæ¾¡å‡ºæ¥çš„äºº (çº¿ç¨‹)
  - äº¤è¿˜æ‰‹ç¯ç»™ç®¡ç†å‘˜ï¼›ç®¡ç†å‘˜æŠŠæ‰‹ç¯å†äº¤ç»™æ’é˜Ÿçš„äºº
  - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ç©ºï¼Œä»ç­‰å¾…é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªçº¿ç¨‹å…è®¸æ‰§è¡Œ
  - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œ`*lk = âœ…`
- ç®¡ç†å‘˜ (OS) ä½¿ç”¨è‡ªæ—‹é”ç¡®ä¿è‡ªå·±å¤„ç†æ‰‹ç¯çš„è¿‡ç¨‹æ˜¯åŸå­çš„

**è‡ªæ—‹é”å’Œç¡çœ é”å„æœ‰è‡ªå·±çš„ä¼˜ç‚¹å’Œç¼ºç‚¹**

è‡ªæ—‹é” (çº¿ç¨‹ç›´æ¥å…±äº« locked)

- æ›´å¿«çš„ fast path
  - xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
- æ›´æ…¢çš„ slow path
  - xchg å¤±è´¥ â†’ æµªè´¹ CPU è‡ªæ—‹ç­‰å¾…

ç¡çœ é” (é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—® locked)

- æ›´å¿«çš„ slow path
  - ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨ CPU
- æ›´æ…¢çš„ fast path
  - å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ (syscall)

é‚£ä¹ˆæ˜¯å¦æœ‰ä¸¤ç§éƒ½è¦çš„é”å‘¢

- Fast path: ä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›
- Slow path: ä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 
  - æ€§èƒ½ä¼˜åŒ–çš„æœ€å¸¸è§æŠ€å·§
    - çœ‹ average (frequent) case è€Œä¸æ˜¯ worst case

------

POSIX çº¿ç¨‹åº“ä¸­çš„äº’æ–¥é” (`pthread_mutex`)

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
mutexlock_t lock = MUTEX_INIT();

long n, sum = 0;

void Tsum() {
  for (int i = 0; i < n; i++) {
    mutex_lock(&lock);
    sum++;
    mutex_unlock(&lock);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  int nthread = atoi(argv[1]);
  n = N / nthread;
  for (int i = 0; i < nthread; i++) {
    create(Tsum);
  }
  join();
  assert(sum == n * nthread);
}
```

#### Futexçš„å®ç°

å¯ä»¥å‘ç°æ˜æ˜¾æ”¹å–„äº†å¤šçº¿ç¨‹çš„æ—¶å€™è‡ªæ—‹é”çš„ç¼ºç‚¹ã€‚

é‚£ä¹ˆFutexå¦‚ä½•å®ç°çš„å‘¢

å…ˆåœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹

- å¦‚æœè·å¾—é”ï¼Œç›´æ¥è¿›å…¥
- æœªèƒ½è·å¾—é”ï¼Œç³»ç»Ÿè°ƒç”¨
- è§£é”ä»¥åä¹Ÿéœ€è¦ç³»ç»Ÿè°ƒç”¨
  - [futex.py](http://jyywiki.cn/pages/OS/2022/demos/futex.py)
  - æ›´å¥½çš„è®¾è®¡å¯ä»¥åœ¨ fast-path ä¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨

::: note Futex

[Futex overview and update](https://lwn.net/Articles/360699/)

[Futex are tricky](http://jyywiki.cn/pages/OS/manuals/futexes-are-tricky.pdf)

:::



### åŒæ­¥

::: tip åŒæ­¥æ¦‚å¿µ

#### åŒæ­¥ (Synchronization)

ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šéšæ—¶é—´å˜åŒ–çš„é‡åœ¨å˜åŒ–è¿‡ç¨‹ä¸­ä¿æŒä¸€å®šçš„ç›¸å¯¹å…³ç³»

- iPhone/iCloud åŒæ­¥ (æ‰‹æœº vs ç”µè„‘ vs äº‘ç«¯)
- å˜é€Ÿç®±åŒæ­¥å™¨ (åˆå¹¶å¿«æ…¢é€Ÿé½¿è½®)
- åŒæ­¥ç”µæœº (è½¬å­ä¸ç£åœºé€Ÿåº¦ä¸€è‡´)
- åŒæ­¥ç”µè·¯ (æ‰€æœ‰è§¦å‘å™¨åœ¨è¾¹æ²¿åŒæ—¶è§¦å‘)

------

å¼‚æ­¥ (Asynchronous) = ä¸åŒæ­¥

- ä¸Šè¿°å¾ˆå¤šä¾‹å­éƒ½æœ‰å¼‚æ­¥ç‰ˆæœ¬ (å¼‚æ­¥ç”µæœºã€å¼‚æ­¥ç”µè·¯ã€å¼‚æ­¥çº¿ç¨‹)

::: 

#### ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ï¼šå­¦åºŸä½ å°±èµ¢äº†

> 99% çš„å®é™…å¹¶å‘é—®é¢˜éƒ½å¯ä»¥ç”¨ç”Ÿäº§è€…-æ¶ˆè´¹è€…è§£å†³ã€‚

```
void Tproduce() { while (1) printf("("); }
void Tconsume() { while (1) printf(")"); }
```

åœ¨ `printf` å‰åå¢åŠ ä»£ç ï¼Œä½¿å¾—æ‰“å°çš„æ‹¬å·åºåˆ—æ»¡è¶³

- ä¸€å®šæ˜¯æŸä¸ªåˆæ³•æ‹¬å·åºåˆ—çš„å‰ç¼€

- æ‹¬å·åµŒå¥—çš„æ·±åº¦ä¸è¶…è¿‡

   

  n*n*

  - n=3*n*=3, `((())())(((` åˆæ³•
  - n=3*n*=3, `(((())))`, `(()))` ä¸åˆæ³•

- åŒæ­¥

  - ç­‰åˆ°æœ‰ç©ºä½å†æ‰“å°å·¦æ‹¬å·
  - ç­‰åˆ°èƒ½é…å¯¹æ—¶å†æ‰“å°å³æ‹¬å·

ä¸ºä»€ä¹ˆå« â€œç”Ÿäº§è€…-æ¶ˆè´¹è€…â€ è€Œä¸æ˜¯ â€œæ‹¬å·é—®é¢˜â€ï¼Ÿ

- å·¦æ‹¬å·ï¼šç”Ÿäº§èµ„æº (ä»»åŠ¡)ã€æ”¾å…¥é˜Ÿåˆ—
- å³æ‹¬å·ï¼šä»é˜Ÿåˆ—å–å‡ºèµ„æº (ä»»åŠ¡) æ‰§è¡Œ

------

èƒ½å¦ç”¨äº’æ–¥é”å®ç°æ‹¬å·é—®é¢˜ï¼Ÿ

- å·¦æ‹¬å·ï¼šåµŒå¥—æ·±åº¦ (é˜Ÿåˆ—) ä¸è¶³ n*n* æ—¶æ‰èƒ½æ‰“å°
- å³æ‹¬å·ï¼šåµŒå¥—æ·±åº¦ (é˜Ÿåˆ—)>1æ—¶æ‰èƒ½æ‰“å°
  - å½“ç„¶æ˜¯ç­‰åˆ°æ»¡è¶³æ¡ä»¶æ—¶å†æ‰“å°äº†
    - ç”¨äº’æ–¥é”ä¿æŒæ¡ä»¶æˆç«‹
  - å‹åŠ›æµ‹è¯•çš„æ£€æŸ¥å½“ç„¶ä¸èƒ½å°‘ï¼š[pc-check.py](http://jyywiki.cn/pages/OS/2022/demos/pc-check.py)
  - Model checker å½“ç„¶ä¹Ÿä¸èƒ½å°‘ (ç•™ä½œä¹ é¢˜)ss

```c
#include "thread.h"
#include "thread-sync.h"

int n, count = 0;
mutex_t lk = MUTEX_INIT();

void Tproduce() {
  while (1) {
retry:
    mutex_lock(&lk);
    if (count == n) {
      mutex_unlock(&lk);
      goto retry;
    }
    count++;
    printf("(");
    mutex_unlock(&lk);
  }
}

void Tconsume() {
  while (1) {
retry:
    mutex_lock(&lk);
    if (count == 0) {
      mutex_unlock(&lk);
      goto retry;
    }
    count--;
    printf(")");
    mutex_unlock(&lk);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  n = atoi(argv[1]);
  setbuf(stdout, NULL);
  for (int i = 0; i < 8; i++) {
    create(Tproduce);
    create(Tconsume);
  }
}
```



ä½†æ˜¯è¿™æ ·è¿˜æ˜¯ä¼šæœ‰è‡ªæ—‹çš„æ“ä½œ

å¦‚ä½•é¿å…å‘¢

#### Conditional Variables (æ¡ä»¶å˜é‡, CV)

æŠŠä¸Šè¿°ä»£ç ä¸­çš„è‡ªæ—‹å˜æˆç¡çœ 

- åœ¨å®Œæˆæ“ä½œæ—¶å”¤é†’

------

æ¡ä»¶å˜é‡ API

- wait(cv, mutex) ğŸ’¤
  - è°ƒç”¨æ—¶å¿…é¡»ä¿è¯å·²ç»è·å¾— mutex
  - é‡Šæ”¾ mutexã€è¿›å…¥ç¡çœ çŠ¶æ€
- signal/notify(cv) ğŸ’¬ ç§ä¿¡ï¼šèµ°èµ·
  - å¦‚æœæœ‰çº¿ç¨‹æ­£åœ¨ç­‰å¾… cvï¼Œåˆ™å”¤é†’å…¶ä¸­ä¸€ä¸ªçº¿ç¨‹
- broadcast/notifyAll(cv) ğŸ“£ æ‰€æœ‰äººï¼šèµ°èµ·
  - å”¤é†’å…¨éƒ¨æ­£åœ¨ç­‰å¾… cv çš„çº¿ç¨‹



é€šè¿‡æ¡ä»¶å˜é‡çš„ä»£ç 

æˆ‘ä»¬å¯ä»¥å®ç°åˆšåˆšçš„é—®é¢˜

```c
void Tproduce() {
  mutex_lock(&lk);
  if (count == n) cond_wait(&cv, &lk);
  printf("("); count++; cond_signal(&cv);
  mutex_unlock(&lk);
}

void Tconsume() {
  mutex_lock(&lk);
  if (count == 0) cond_wait(&cv, &lk);
  printf(")"); count--; cond_signal(&cv);
  mutex_unlock(&lk);
}
```

ä½†æ˜¯è¿™æ ·çš„ä»£ç åœ¨é¢ä¸´ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¸å¯¹ç­‰çš„æ—¶å€™æ˜¯ä¸æˆç«‹çš„ã€‚

æ‰€ä»¥éœ€è¦ä¸¤ä¸ªæ¡ä»¶å˜é‡æ¥æ§åˆ¶åŒç±»ä¸å”¤é†’ã€‚

**æ¡ä»¶å˜é‡ï¼šæ­£ç¡®çš„æ‰“å¼€æ–¹å¼**

éœ€è¦ç­‰å¾…æ¡ä»¶æ»¡è¶³æ—¶

```
mutex_lock(&mutex);
while (!cond) {
  wait(&cv, &mutex);
}
assert(cond);
// ...
// äº’æ–¥é”ä¿è¯äº†åœ¨æ­¤æœŸé—´æ¡ä»¶ cond æ€»æ˜¯æˆç«‹
// ...
mutex_unlock(&mutex);
```

å…¶ä»–çº¿ç¨‹æ¡ä»¶å¯èƒ½è¢«æ»¡è¶³æ—¶

```
broadcast(&cv);
```

éšåæ¥æŒ‘æˆ˜ä¸€ä¸ªæ›´ä¸ºå¤æ‚çš„é¢˜ç›®ï¼

::: warn æ‰“å°ä¸€æ¡é±¼

æœ‰ä¸‰ç§çº¿ç¨‹ï¼Œåˆ†åˆ«æ‰“å° `<`, `>`, å’Œ `_`

- å¯¹è¿™äº›çº¿ç¨‹è¿›è¡ŒåŒæ­¥ï¼Œä½¿å¾—æ‰“å°å‡ºçš„åºåˆ—æ€»æ˜¯ `<><_` å’Œ `><>_` ç»„åˆ

------

ä½¿ç”¨æ¡ä»¶å˜é‡ï¼Œåªè¦å›ç­”ä¸‰ä¸ªé—®é¢˜ï¼š

- æ‰“å° â€œ`<`â€ çš„æ¡ä»¶ï¼Ÿ
- æ‰“å° â€œ`>`â€ çš„æ¡ä»¶ï¼Ÿ
- æ‰“å° â€œ`_`â€ çš„æ¡ä»¶ï¼Ÿ

::: 

ç”»çŠ¶æ€æœº åŒæ—¶è§£å†³å³å¯

```c
#include "thread.h"

#define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

enum { A = 1, B, C, D, E, F, };

struct rule {
  int from, ch, to;
};

struct rule rules[] = {
  { A, '<', B },
  { B, '>', C },
  { C, '<', D },
  { A, '>', E },
  { E, '<', F },
  { F, '>', D },
  { D, '_', A },
};
int current = A, quota = 1;

pthread_mutex_t lk   = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cond = PTHREAD_COND_INITIALIZER;

int next(char ch) {
  for (int i = 0; i < LENGTH(rules); i++) {
    struct rule *rule = &rules[i];
    if (rule->from == current && rule->ch == ch) {
      return rule->to;
    }
  }
  return 0;
}

void fish_before(char ch) {
  pthread_mutex_lock(&lk);
  while (!(next(ch) && quota)) {
    // can proceed only if (next(ch) && quota)
    pthread_cond_wait(&cond, &lk);
  }
  quota--;
  pthread_mutex_unlock(&lk);
}

void fish_after(char ch) {
  pthread_mutex_lock(&lk);
  quota++;
  current = next(ch);
  assert(current);
  pthread_cond_broadcast(&cond);
  pthread_mutex_unlock(&lk);
}

const char roles[] = ".<<<<<>>>>___";

void fish_thread(int id) {
  char role = roles[id];
  while (1) {
    fish_before(role);
    putchar(role); // can be long; no lock protection
    fish_after(role);
  }
}

int main() {
  setbuf(stdout, NULL);
  for (int i = 0; i < strlen(roles); i++)
    create(fish_thread);
}
```



#### ä¿¡å·é‡ï¼šå®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…

åšä¸€ç‚¹æ‰©å±•â€”â€”çº¿ç¨‹å¯ä»¥ä»»æ„ â€œå˜å‡ºâ€ ä¸€ä¸ªæ‰‹ç¯

- æŠŠæ‰‹ç¯çœ‹æˆæ˜¯ä»¤ç‰Œ
- å¾—åˆ°ä»¤ç‰Œçš„å¯ä»¥è¿›å…¥æ‰§è¡Œ
- å¯ä»¥éšæ—¶åˆ›å»ºä»¤ç‰Œ

------

â€œæ‰‹ç¯â€ = â€œä»¤ç‰Œâ€ = â€œä¸€ä¸ªèµ„æºâ€ = â€œä¿¡å·é‡â€ (semaphore)

- P(&sem) - prolaag = try + decrease; wait; down; in
  - ç­‰å¾…ä¸€ä¸ªæ‰‹ç¯åè¿”å›
  - å¦‚æœæ­¤æ—¶ç®¡ç†å‘˜æ‰‹ä¸Šæœ‰ç©ºé—²çš„æ‰‹ç¯ï¼Œç«‹å³è¿”å›
- V(&sem) - verhoog = increase; post; up; out
  - å˜å‡ºä¸€ä¸ªæ‰‹ç¯ï¼Œé€ç»™ç®¡ç†å‘˜

ä¿¡å·é‡è®¾è®¡çš„é‡ç‚¹

- è€ƒè™‘ â€œæ‰‹ç¯â€ (æ¯ä¸€å•ä½çš„ â€œèµ„æºâ€) æ˜¯ä»€ä¹ˆï¼Œè°åˆ›é€ ï¼Ÿè°è·å–ï¼Ÿ
  - [`pc-sem.c`](http://jyywiki.cn/pages/OS/2022/demos/pc-sem.c)

```
void producer() {
  P(&empty);   // P()è¿”å› -> å¾—åˆ°æ‰‹ç¯
  printf("("); // å‡è®¾çº¿ç¨‹å®‰å…¨
  V(&fill);
}
void consumer() {
  P(&fill);
  printf(")");
  V(&empty);
}
```

- åœ¨ â€œä¸€å•ä½èµ„æºâ€ æ˜ç¡®çš„é—®é¢˜ä¸Šæ›´å¥½ç”¨



#### å“²å­¦å®¶åƒé¥­é—®é¢˜

```c
mutex_lock(&mutex);
while (!(avail[lhs] && avail[rhs])) {
  wait(&cv, &mutex);
}
avail[lhs] = avail[rhs] = false;
mutex_unlock(&mutex);

mutex_lock(&mutex);
avail[lhs] = avail[rhs] = true;
broadcast(&cv);
mutex_unlock(&mutex);
```

åˆ†å¸ƒå¼çš„è§£å†³æ–¹æ¡ˆ

å¦ä¸€æ–¹é¢æ˜¯é›†ä¸­å¼

```c
void Tphilosopher(int id) {
  send_request(id, EAT);
  P(allowed[id]); // waiter ä¼šæŠŠå‰å­é€’ç»™å“²å­¦å®¶
  philosopher_eat();
  send_request(id, DONE);
}

void Twaiter() {
  while (1) {
    (id, status) = receive_request();
    if (status == EAT) { ... }
    if (status == DONE) { ... }
  }
}
```

åˆ©ç”¨ä¸€ä¸ªwaiteræ¥é›†ä¸­ç»™å“²å­¦å®¶åˆ†é…å‰å­

ä½ å¯èƒ½ä¼šè§‰å¾—ï¼Œç®¡å‰å­çš„äººæ˜¯æ€§èƒ½ç“¶é¢ˆ

- ä¸€å¤§æ¡Œäººåƒé¥­ï¼Œæ¯ä¸ªäººéƒ½å«æœåŠ¡å‘˜çš„æ„Ÿè§‰
- Premature optimization is the root of all evil (D. E. Knuth)

------

æŠ›å¼€ workload è°ˆä¼˜åŒ–å°±æ˜¯è€æµæ°“

- åƒé¥­çš„æ—¶é—´é€šå¸¸è¿œè¿œå¤§äºè¯·æ±‚æœåŠ¡å‘˜çš„æ—¶é—´
- å¦‚æœä¸€ä¸ª manager æä¸å®šï¼Œå¯ä»¥åˆ†å¤šä¸ª (fast/slow path)
  - æŠŠç³»ç»Ÿè®¾è®¡å¥½ï¼Œä½¿é›†ä¸­ç®¡ç†ä¸æˆä¸ºç“¶é¢ˆ
    - [Millions of tiny databases](https://www.usenix.org/conference/nsdi20/presentation/brooker) (NSDI'20)

### **ç°å®ç”Ÿæ´»ä¸­çš„å¹¶å‘ç¨‹åº**

::: tip å¹¶å‘ç¨‹åºé‡åˆ°çš„ä¸»è¦æŒ‘æˆ˜

**è®¡ç®—ä»»åŠ¡å¦‚ä½•åˆ†è§£**

- è®¡ç®—å›¾éœ€è¦å®¹æ˜“å¹¶è¡ŒåŒ–
  - æœºå™¨-çº¿ç¨‹ä¸¤çº§ä»»åŠ¡åˆ†è§£
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…è§£å†³ä¸€åˆ‡
  - [MPI](https://hpc-tutorials.llnl.gov/mpi/) - â€œa specification for the developers and users of message passing librariesâ€, [OpenMP](https://www.openmp.org/) - â€œmulti-platform shared-memory parallel programming in C/C++ and Fortranâ€
- [Parallel and Distributed Computation: Numerical Methods](https://web.mit.edu/dimitrib/www/pdc.html)

------

**çº¿ç¨‹é—´å¦‚ä½•é€šä¿¡**

- é€šä¿¡ä¸ä»…å‘ç”Ÿåœ¨èŠ‚ç‚¹/çº¿ç¨‹ä¹‹é—´ï¼Œè¿˜å‘ç”Ÿåœ¨ä»»ä½•å…±äº«å†…å­˜è®¿é—®

:::

#### æ•°æ®ä¸­å¿ƒï¼šåç¨‹å’Œçº¿ç¨‹

æ•°æ®ä¸­å¿ƒ

- åŒä¸€æ—¶é—´æœ‰æ•°åƒ/æ•°ä¸‡ä¸ªè¯·æ±‚åˆ°è¾¾æœåŠ¡å™¨
- è®¡ç®—éƒ¨åˆ†
  - éœ€è¦åˆ©ç”¨å¥½å¤šå¤„ç†å™¨
    - çº¿ç¨‹ â†’ è¿™å°±æ˜¯æˆ‘æ“…é•¿çš„ (Mandelbrot Set)
    - åç¨‹ â†’ ä¸€äººå‡ºåŠ›ï¼Œä»–äººæ‘¸é±¼
- I/O éƒ¨åˆ†
  - ä¼šåœ¨ç³»ç»Ÿè°ƒç”¨ä¸Š block (ä¾‹å¦‚è¯·æ±‚å¦ä¸€ä¸ªæœåŠ¡æˆ–è¯»ç£ç›˜)
    - åç¨‹ â†’ ä¸€äººå¹²ç­‰ï¼Œä»–äººå›´è§‚
    - çº¿ç¨‹ â†’ æ¯ä¸ªçº¿ç¨‹éƒ½å ç”¨å¯è§‚çš„æ“ä½œç³»ç»Ÿèµ„æº
- (è¿™ä¸ªé—®é¢˜æ¯”ä½ æƒ³è±¡çš„å¤æ‚ï¼Œä¾‹å¦‚è™šæ‹Ÿæœº)

#### Go å’Œ Goroutine

> Go: å°å­©å­æ‰åšé€‰æ‹©ï¼Œå¤šå¤„ç†å™¨å¹¶è¡Œå’Œè½»é‡çº§å¹¶å‘æˆ‘å…¨éƒ½è¦ï¼

Goroutine: æ¦‚å¿µä¸Šæ˜¯çº¿ç¨‹ï¼Œå®é™…æ˜¯çº¿ç¨‹å’Œåç¨‹çš„æ··åˆä½“

- æ¯ä¸ª CPU ä¸Šæœ‰ä¸€ä¸ª Go Workerï¼Œè‡ªç”±è°ƒåº¦ goroutines
- æ‰§è¡Œåˆ° blocking API æ—¶ (ä¾‹å¦‚ sleep, read)
  - Go Worker å·å·æ”¹æˆ non-blocking çš„ç‰ˆæœ¬
    - æˆåŠŸ â†’ ç«‹å³ç»§ç»­æ‰§è¡Œ
    - å¤±è´¥ â†’ ç«‹å³ yield åˆ°å¦ä¸€ä¸ªéœ€è¦ CPU çš„ goroutine
      - å¤ªå·§å¦™äº†ï¼CPU å’Œæ“ä½œç³»ç»Ÿå…¨éƒ¨ç”¨åˆ° 100%

------

ä¾‹å­

- [fib.go](http://jyywiki.cn/pages/OS/2022/demos/fib.go); 
- [The Go Programming Language (ch 9.8)](https://books.studygolang.com/gopl-zh/ch9/ch9-08.html)

Goè§£å†³äº†ä¸¤ä¸ªå¤§é—®é¢˜ï¼Œä¸€ä¸ªæ˜¯çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶çš„å¼€é”€ï¼Œä¸€ä¸ªæ˜¯åç¨‹åœ¨é‡åˆ°IOæ“ä½œæ—¶ä¼šé‡åˆ°çš„åˆ‡æ¢çº¿ç¨‹ã€‚

é€šè¿‡channelæ¥è¿›è¡Œçº¿ç¨‹é—´çš„é€šä¿¡ï¼Œé¿å…äº†å…±äº«å†…å­˜çš„éº»çƒ¦ã€‚



## å¹¶å‘BUGåº”å¯¹æ–¹æ³•

é˜²å¾¡æ€§ç¼–ç¨‹

å¤šç”¨Assertæ–­è¨€æ¥åˆ¤æ–­æ“ä½œæ˜¯å¦æ­£ç¡®



### æ­»é”

#### AA-Deadlock

å‡è®¾ä½ çš„ spinlock ä¸å°å¿ƒå‘ç”Ÿäº†ä¸­æ–­

- åœ¨ä¸è¯¥æ‰“å¼€ä¸­æ–­çš„æ—¶å€™å¼€äº†ä¸­æ–­
- åœ¨ä¸è¯¥åˆ‡æ¢çš„æ—¶å€™æ‰§è¡Œäº† `yield()`

------

```
void os_run() {
  spin_lock(&list_lock);
  spin_lock(&xxx);
  spin_unlock(&xxx); // ---------+
}                          //    |
                           //    |
void on_interrupt() {      //    |
  spin_lock(&list_lock);   // <--+
  spin_unlock(&list_lock);
}
```

#### ABBA-Deadlock

```
void swap(int i, int j) {
  spin_lock(&lock[i]);
  spin_lock(&lock[j]);
  arr[i] = NULL;
  arr[j] = arr[i];
  spin_unlock(&lock[j]);
  spin_unlock(&lock[i]);
}
```

------

ä¸Šé”çš„é¡ºåºå¾ˆé‡è¦â€¦â€¦

- ```
  swap
  ```

   

  æœ¬èº«çœ‹èµ·æ¥æ²¡æœ‰é—®é¢˜

  - `swap(1, 2)`; `swap(2, 3)`, `swap(3, 1)` â†’ æ­»é”
  - [philosopher.c](http://jyywiki.cn/pages/OS/2022/demos/philosopher.c)

é¿å…æ­»é”

æ­»é”äº§ç”Ÿçš„å››ä¸ªå¿…è¦æ¡ä»¶ ([Edward G. Coffman](https://en.wikipedia.org/wiki/Edward_G._Coffman,_Jr.), 1971):

- äº’æ–¥ï¼šä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨
- è¯·æ±‚ä¸ä¿æŒï¼šä¸€ä¸ªè¿›ç¨‹è¯·æ±‚èµ„é˜»å¡æ—¶ï¼Œä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº
- ä¸å‰¥å¤ºï¼šè¿›ç¨‹å·²è·å¾—çš„èµ„æºä¸èƒ½å¼ºè¡Œå‰¥å¤º
- å¾ªç¯ç­‰å¾…ï¼šè‹¥å¹²è¿›ç¨‹ä¹‹é—´å½¢æˆå¤´å°¾ç›¸æ¥çš„å¾ªç¯ç­‰å¾…èµ„æºå…³ç³»

------

> â€œç†è§£äº†æ­»é”çš„åŸå› ï¼Œå°¤å…¶æ˜¯äº§ç”Ÿæ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶ï¼Œå°±å¯ä»¥æœ€å¤§å¯èƒ½åœ°é¿å…ã€é¢„é˜²å’Œè§£é™¤æ­»é”ã€‚æ‰€ä»¥ï¼Œåœ¨ç³»ç»Ÿè®¾è®¡ã€è¿›ç¨‹è°ƒåº¦ç­‰æ–¹é¢æ³¨æ„å¦‚ä½•ä¸è®©è¿™å››ä¸ªå¿…è¦æ¡ä»¶æˆç«‹ï¼Œå¦‚ä½•ç¡®å®šèµ„æºçš„åˆç†åˆ†é…ç®—æ³•ï¼Œé¿å…è¿›ç¨‹æ°¸ä¹…å æ®ç³»ç»Ÿèµ„æºã€‚æ­¤å¤–ï¼Œä¹Ÿè¦é˜²æ­¢è¿›ç¨‹åœ¨å¤„äºç­‰å¾…çŠ¶æ€çš„æƒ…å†µä¸‹å ç”¨èµ„æºã€‚å› æ­¤ï¼Œå¯¹èµ„æºçš„åˆ†é…è¦ç»™äºˆåˆç†çš„è§„åˆ’ã€‚â€ â€”â€”Bullshit.

#### é¿å…æ­»é” (cont'd)

AA-Deadlock

- AA å‹çš„æ­»é”å®¹æ˜“æ£€æµ‹ï¼ŒåŠæ—©æŠ¥å‘Šï¼ŒåŠæ—©ä¿®å¤
- spinlock-xv6.c ä¸­çš„å„ç§é˜²å¾¡æ€§ç¼–ç¨‹
  - `if (holding(lk)) panic();`

------

ABBA-Deadlock

- ä»»æ„æ—¶åˆ»ç³»ç»Ÿä¸­çš„é”éƒ½æ˜¯æœ‰é™çš„
- ä¸¥æ ¼æŒ‰ç…§å›ºå®šçš„é¡ºåºè·å¾—æ‰€æœ‰é” (lock ordering; æ¶ˆé™¤ â€œå¾ªç¯ç­‰å¾…â€)
  - é‡äº‹ä¸å†³å¯è§†åŒ–ï¼š[lock-ordering.py](http://jyywiki.cn/pages/OS/2022/demos/lock-ordering.py)
  - è¿›è€Œè¯æ˜æ˜¯å®‰å…¨çš„
    - â€œåœ¨ä»»æ„æ—¶åˆ»æ€»æ˜¯æœ‰è·å¾— â€œæœ€é åâ€ é”çš„å¯ä»¥ç»§ç»­æ‰§è¡Œâ€



### æ•°æ®ç«äº‰

> ä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ®µå†…å­˜ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™ã€‚

- ä¸¤ä¸ªå†…å­˜è®¿é—®åœ¨ â€œèµ›è·‘â€ï¼Œâ€œè·‘èµ¢â€ çš„æ“ä½œå…ˆæ‰§è¡Œ

  - peterson-barrier.c

    : å†…å­˜è®¿é—®éƒ½åœ¨èµ›è·‘

    - [MFENCE](https://www.felixcloutier.com/x86/mfence)ï¼š~~å¦‚ä½•ç•™ä¸‹æœ€å°‘çš„ fenceï¼Œä¾ç„¶ä¿è¯ç®—æ³•æ­£ç¡®ï¼Ÿ~~

ç”¨äº’æ–¥é”ä¿æŠ¤æ•°æ®ï¼Œé¿å…æ•°æ®ç«äº‰

### å…¶ä»–BUG

```c
// Case #1: ä¸Šé”™äº†é”
void thread1() { spin_lock(&lk1); sum++; spin_unlock(&lk1); }
void thread2() { spin_lock(&lk2); sum++; spin_unlock(&lk2); }
```

------

```c
// Case #2: å¿˜è®°ä¸Šé”
void thread1() { spin_lock(&lk1); sum++; spin_unlock(&lk1); }
void thread2() { sum++; }
```

#### åŸå­æ€§è¿å (AV)

â€œABAâ€

- æˆ‘ä»¥ä¸ºä¸€æ®µä»£ç æ²¡å•¥äº‹å‘¢ï¼Œä½†è¢«äººå¼ºåŠ¿æ’å…¥äº†

![ABA](http://jyywiki.cn/pages/OS/img/av-bug.png)

#### é¡ºåºè¿å (OV)

â€œBAâ€

- æ€ä¹ˆå°±æ²¡æŒ‰æˆ‘é¢„æƒ³çš„é¡ºåºæ¥å‘¢ï¼Ÿ
  - ä¾‹å­ï¼šconcurrent use after free

![OV](http://jyywiki.cn/pages/OS/img/ov-bug.png)

### åº”å¯¹é”™è¯¯çš„æ–¹æ³•

#### Lockdep: è¿è¡Œæ—¶çš„æ­»é”æ£€æŸ¥

Lockdep è§„çº¦ (Specification)

- ä¸ºæ¯ä¸€ä¸ªé”ç¡®å®šå”¯ä¸€çš„ â€œallocation siteâ€
  - [lock-site.c](http://jyywiki.cn/pages/OS/2022/demos/lock-site.c)
  - assert: åŒä¸€ä¸ª allocation site çš„é”å­˜åœ¨å…¨å±€å”¯ä¸€çš„ä¸Šé”é¡ºåº

æ£€æŸ¥æ–¹æ³•ï¼šprintf

- è®°å½•æ‰€æœ‰è§‚å¯Ÿåˆ°çš„ä¸Šé”é¡ºåºï¼Œä¾‹å¦‚

ç»´æŠ¤çš„å…¶å®æ˜¯ä¸€ä¸ªå›¾ï¼Œå¦‚æœå›¾ä¸­æœ‰ç¯ï¼Œåˆ™è¿èƒŒäº†åŠ é”çš„é¡ºåºã€‚

#### ThreadSanitizer: è¿è¡Œæ—¶çš„æ•°æ®ç«äº‰æ£€æŸ¥

ä¸ºæ‰€æœ‰äº‹ä»¶å»ºç«‹ happens-before å…³ç³»å›¾

- Program-order + release-acquire
- å¯¹äºå‘ç”Ÿåœ¨ä¸åŒçº¿ç¨‹ä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™çš„ x,y*x*,*y* æ£€æŸ¥

è¿˜æ˜¯è¦ä¾é å·¥å…·åšæ£€æŸ¥ï¼

## åŠ¨æ€åˆ†æå·¥å…·ï¼šSanitizers

æ²¡ç”¨è¿‡ lint/sanitizersï¼Ÿ

- AddressSanitizer(asan);(paper): éæ³•å†…å­˜è®¿é—®
  - Buffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, ...
  - Demo: [uaf.c](http://jyywiki.cn/pages/OS/2022/demos/uaf.c); [kasan](https://www.kernel.org/doc/html/latest/dev-tools/kasan.html)
- ThreadSanitizer(tsan): æ•°æ®ç«äº‰
  - Demo: [fish.c](http://jyywiki.cn/pages/OS/2022/demos/fish.c), [sum.c](http://jyywiki.cn/pages/OS/2022/demos/sum.c), [peterson-barrier.c](http://jyywiki.cn/pages/OS/2022/demos/peterson-barrier.c); [ktsan](https://github.com/google/ktsan)
- [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html) (msan): æœªåˆå§‹åŒ–çš„è¯»å–
- UBSanitizer(ubsan): undefined behavior
  - Misaligned pointer, signed integer overflow, ...
  - Kernel ä¼šå¸¦ç€ `-fwrapv` ç¼–è¯‘
