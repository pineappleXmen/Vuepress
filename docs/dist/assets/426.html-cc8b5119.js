import{_ as e,V as t,W as o,Y as n,Z as s,$ as p,a0 as l,D as c}from"./framework-3845b112.js";const i={},r={id:"_426-将二叉搜索树转化为排序的双向链表",tabindex:"-1"},d=n("a",{class:"header-anchor",href:"#_426-将二叉搜索树转化为排序的双向链表","aria-hidden":"true"},"#",-1),u={href:"https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/",target:"_blank",rel:"noopener noreferrer"},k=l(`<p>难度中等187</p><p>将一个 <strong>二叉搜索树</strong> 就地转化为一个 <strong>已排序的双向循环链表</strong> 。</p><p>对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>特别地，我们希望可以 <strong>就地</strong> 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [4,2,5,1,3] 


输出：[1,2,3,4,5]

解释：下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [2,1,3]
输出：[1,2,3]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = []
输出：[]
解释：输入是空树，所以输出也是空链表。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 4：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1]
输出：[1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>Node.left.val &lt; Node.val &lt; Node.right.val</code></li><li><code>Node.val</code> 的所有值都是独一无二的</li><li><code>0 &lt;= Number of Nodes &lt;= 2000</code></li></ul><p>通过次数12,109</p><p>提交次数17,777</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> leftOne <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>left <span class="token operator">=</span> leftOne<span class="token punctuation">;</span>
        leftOne<span class="token punctuation">.</span>right <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> cur<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> head <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftOne<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> leftOne<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>left <span class="token operator">=</span> leftOne<span class="token punctuation">;</span>
        leftOne <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17);function v(m,b){const a=c("ExternalLinkIcon");return t(),o("div",null,[n("h4",r,[d,s(),n("a",u,[s("426. 将二叉搜索树转化为排序的双向链表"),p(a)])]),k])}const f=e(i,[["render",v],["__file","426.html.vue"]]);export{f as default};
