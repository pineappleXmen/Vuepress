import{_ as e,V as a,W as i,a0 as r}from"./framework-3845b112.js";const n="/spring/springadvance/image-20220825123019978.png",p="/spring/springadvance/image-20220825124448297.png",t="/spring/springadvance/image-20220825125148601.png",o="/spring/springadvance/image-20220825130540338.png",s="/spring/springadvance/image-20220825135823899.png",l="/spring/springadvance/image-20220825145442932.png",d="/spring/springadvance/image-20220825145537481.png",h="/spring/springadvance/image-20220825145655091.png",c={},u=r('<h2 id="_1-applicationcontext的refresh方法干了什么" tabindex="-1"><a class="header-anchor" href="#_1-applicationcontext的refresh方法干了什么" aria-hidden="true">#</a> 1.ApplicationContext的refresh方法干了什么？</h2><h3 id="_1-1preparerefresh" tabindex="-1"><a class="header-anchor" href="#_1-1preparerefresh" aria-hidden="true">#</a> 1.1prepareRefresh</h3><p>创建准备Environment环境</p><p>systemProperties、systemEnvironment、PropertySource里的键值信息</p><h3 id="_1-2-obtainfreshbeanfactory" tabindex="-1"><a class="header-anchor" href="#_1-2-obtainfreshbeanfactory" aria-hidden="true">#</a> 1.2 obtainFreshBeanFactory</h3><figure><img src="'+n+'" alt="image-20220825123019978" tabindex="0" loading="lazy"><figcaption>image-20220825123019978</figcaption></figure><p>获取创建BeanFactory、从xml 注解等地方拿到BeanDefinition</p><h3 id="_1-3-preparebeanfactory" tabindex="-1"><a class="header-anchor" href="#_1-3-preparebeanfactory" aria-hidden="true">#</a> 1.3 prepareBeanFactory</h3><p>完善BeanFactory</p><p>beanExpressionResolver：解析表达式</p><p>prepertyEditoregistrars：类型装换</p><p>resolvableDependencies：管理特殊的bean：容器 beanfactory等</p><p>beanPostProcessors：bean后处理器：ApplicationContextAwareProcessor</p><h3 id="_1-4-postprocessorbeanfactory" tabindex="-1"><a class="header-anchor" href="#_1-4-postprocessorbeanfactory" aria-hidden="true">#</a> 1.4 postProcessorBeanFactory</h3><p>模板方法设计模式</p><p>留给子类扩展</p><p>如web环境的需要利用他注册新的Scope 完善beanFactory</p><h3 id="_1-5-invokebeanfactorypostprocessors" tabindex="-1"><a class="header-anchor" href="#_1-5-invokebeanfactorypostprocessors" aria-hidden="true">#</a> 1.5 invokeBeanFactoryPostProcessors</h3><p>充当beanfactory后处理器扩展beandefinition</p><p>如configurationclasspostProcessors 解析@configuration @Bean @Import @Propertysource</p><h3 id="_1-6-registerbeanpostprocessors" tabindex="-1"><a class="header-anchor" href="#_1-6-registerbeanpostprocessors" aria-hidden="true">#</a> 1.6 registerBeanPostProcessors</h3><p>充当bean的扩展点 可以在实例化阶段 依赖注入 初始化阶段扩展</p><p>AutowiredAnnotationBeanPostProcessors @Autowired @ Value</p><h3 id="_1-7-initmessagesource" tabindex="-1"><a class="header-anchor" href="#_1-7-initmessagesource" aria-hidden="true">#</a> 1.7 initMessageSource</h3><p>实现国际化功能</p><p>找单例池有无messageSource实现单例 如果没有就用默认的</p><h3 id="_1-8-initapplicationeventmulticaster" tabindex="-1"><a class="header-anchor" href="#_1-8-initapplicationeventmulticaster" aria-hidden="true">#</a> 1.8 initApplicationEventMulticaster</h3><p>事件处理的步骤 发布事件给监听器</p><p>找是否有multicaster 如果没有就用默认</p><figure><img src="'+p+'" alt="image-20220825124448297" tabindex="0" loading="lazy"><figcaption>image-20220825124448297</figcaption></figure><h3 id="_1-9-onrefresh" tabindex="-1"><a class="header-anchor" href="#_1-9-onrefresh" aria-hidden="true">#</a> 1.9 onRefresh</h3><p>Boot子类可以在这一步准备webserver 内嵌web容器</p><p>模板方法设计模式</p><h3 id="_1-10-registerlisteners" tabindex="-1"><a class="header-anchor" href="#_1-10-registerlisteners" aria-hidden="true">#</a> 1.10 registerListeners</h3><p>注册监听器到map 有事件来的时候到map里找感兴趣的事件</p><p>实现了ApplicationListener接口</p><p>或者编程添加的监听器@EventListener</p><p>接受事件</p><h3 id="_1-11-finishbeanfactoryinitialization" tabindex="-1"><a class="header-anchor" href="#_1-11-finishbeanfactoryinitialization" aria-hidden="true">#</a> 1.11 finishBeanFactoryInitialization</h3><p>conversionService 对propertyEditorRegistrars补充</p><p>embeddedValueResolvers 对${}进行解析</p><p>singletonObjects：根据beandefinition 创建出来 保存单例对象</p><h3 id="_1-12-finishrefresh" tabindex="-1"><a class="header-anchor" href="#_1-12-finishrefresh" aria-hidden="true">#</a> 1.12 finishRefresh</h3><p>注册lifeCycleProcessor 注册bean单例的生命周期管理</p><figure><img src="'+t+'" alt="image-20220825125148601" tabindex="0" loading="lazy"><figcaption>image-20220825125148601</figcaption></figure><h2 id="_2-bean的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-bean的生命周期" aria-hidden="true">#</a> 2.Bean的生命周期</h2><h3 id="_2-1处理名称-检查缓存" tabindex="-1"><a class="header-anchor" href="#_2-1处理名称-检查缓存" aria-hidden="true">#</a> 2.1处理名称，检查缓存</h3><p>如果缓存中有Bean 那么从缓存中取得bean</p><h3 id="_2-2处理父子容器" tabindex="-1"><a class="header-anchor" href="#_2-2处理父子容器" aria-hidden="true">#</a> 2.2处理父子容器</h3><p>如果缓存中没有去父容器找</p><h3 id="_2-3-dependson" tabindex="-1"><a class="header-anchor" href="#_2-3-dependson" aria-hidden="true">#</a> 2.3 dependsOn</h3><p>dependsOn用于没有依赖关系的bean创建的顺序管理</p><h3 id="_2-4按scope创建bean" tabindex="-1"><a class="header-anchor" href="#_2-4按scope创建bean" aria-hidden="true">#</a> 2.4按Scope创建Bean</h3><p>单例bean从容器refresh的时候创建 close的时候销毁 beanfactory会记录谁要调用销毁方法</p><p>多例bean从首次getbean的时候被创建 调用beanfactory的destroybean来销毁</p><p>request从首次调用request创建 关闭request时被销毁</p><p>singleton会缓存bean</p><p>prototype不会缓存 每次创建新的</p><h3 id="_2-5创建bean" tabindex="-1"><a class="header-anchor" href="#_2-5创建bean" aria-hidden="true">#</a> 2.5创建Bean</h3><figure><img src="'+o+'" alt="image-20220825130540338" tabindex="0" loading="lazy"><figcaption>image-20220825130540338</figcaption></figure><h4 id="_5-1-创建bean实例" tabindex="-1"><a class="header-anchor" href="#_5-1-创建bean实例" aria-hidden="true">#</a> 5.1 创建bean实例</h4><p><strong>有自定义TargetSource的情况</strong></p><p>由AnnotationAwareAspectJAutoProxyCreator创建代理返回</p><p><strong>Supplier方式创建bean实例</strong></p><p>supplier不需要通过反射，而是在supplierFactory中直接实例化对象，所以supplier的效率比其他方式要高。</p><p><strong>FactoryMethod方式创建</strong></p><p>静态工厂和实例工厂 有参数需参数解析 多个工厂方法 还需权重筛选</p><p><strong>AntowiredAnnotationBeanPostProcessor创建</strong></p><p>优先选择@autowired注解的构造</p><p>若有唯一的带参构造 也会入选</p><p><strong>默认构造</strong></p><p>没找到合适的 采用默认的构造</p><h4 id="_5-2-依赖注入" tabindex="-1"><a class="header-anchor" href="#_5-2-依赖注入" aria-hidden="true">#</a> 5.2 依赖注入</h4><p><strong>AutowiredAnnotationBeanPostProcessor</strong></p><p>@Autowired @Value 封装为injectionMetadata</p><p><strong>CommonAnnotationBeanPostProcessor</strong></p><p>@Resource</p><p><strong>resolveDependency</strong></p><p>解析Optional包裹的值</p><p>ObjectFactory</p><p>@Lazy</p><p>集合 数组</p><p>泛型 @Qualifier</p><p><strong>AUTOWIRE_BY_NAME</strong></p><p>根据set方法名后的名字 名字来匹配 修改mbd的propertyvalues</p><p><strong>AUTOWIRE_BY_TYPE</strong></p><p>根据类型匹配</p><p><strong>applypropertyValues</strong></p><p>根据mbd的propertyvalues精确匹配</p><h4 id="依赖注入优先级" tabindex="-1"><a class="header-anchor" href="#依赖注入优先级" aria-hidden="true">#</a> 依赖注入优先级</h4><p>@Autowired 最低</p><p>AUTOWIRE_BY_NAME/TYPE 次之</p><p>精确注入 最高</p><h4 id="_5-3-初始化" tabindex="-1"><a class="header-anchor" href="#_5-3-初始化" aria-hidden="true">#</a> 5.3 初始化</h4><p>实现Aware接口</p><p>@PostCounstruct</p><p>由CommonAnnotationBeanpostProcessor解析</p><p>initializingbean接口回调执行初始化</p><p>initmethod指定 或@Bean（init）</p><p>创建aop代理</p><h4 id="初始化优先级" tabindex="-1"><a class="header-anchor" href="#初始化优先级" aria-hidden="true">#</a> <strong>初始化优先级</strong></h4><p>1.Aware接口</p><p>@Postconstruct</p><p>initializingBean</p><p>指定initmethod</p><h4 id="_5-4注册和销毁bean" tabindex="-1"><a class="header-anchor" href="#_5-4注册和销毁bean" aria-hidden="true">#</a> 5.4注册和销毁bean</h4><p>实现了disposablebean接口autocloseable接口为可销毁bena</p><p>自定义了destroymethod 为可销毁bean</p><p>@Bean close</p><p>@Predestroy</p><p>singleton 存在beanfactory 的对象</p><p>自定义scope 存在该域对象中</p><p>prototype不会存储</p><p>存的时候会封装为disposablebeanadapter 适配器模式</p><h3 id="_2-6-类型转换" tabindex="-1"><a class="header-anchor" href="#_2-6-类型转换" aria-hidden="true">#</a> 2.6 类型转换</h3><p>getbean的requiretype不是真的类型 需要转换</p><h3 id="_2-7-销毁bean" tabindex="-1"><a class="header-anchor" href="#_2-7-销毁bean" aria-hidden="true">#</a> 2.7 销毁bean</h3><p>singleton bean的销毁在applicationcontext是 逐一找到disposablebean的名字 逐一销毁</p><h4 id="优先级" tabindex="-1"><a class="header-anchor" href="#优先级" aria-hidden="true">#</a> 优先级</h4><p>@predestroy</p><p>disposablebean</p><p>destroymethod</p><figure><img src="'+s+'" alt="image-20220825135823899" tabindex="0" loading="lazy"><figcaption>image-20220825135823899</figcaption></figure><h2 id="_3-spring事务失效场景" tabindex="-1"><a class="header-anchor" href="#_3-spring事务失效场景" aria-hidden="true">#</a> 3.Spring事务失效场景</h2><h4 id="_3-1-检查异常不会回滚-默认只会检查error、runtimeexception-等非检查异常" tabindex="-1"><a class="header-anchor" href="#_3-1-检查异常不会回滚-默认只会检查error、runtimeexception-等非检查异常" aria-hidden="true">#</a> 3.1 检查异常不会回滚（默认只会检查error、runtimeexception 等非检查异常）</h4><p>解决方法：@Transactional(rollbackfor = Exception.class)</p><h4 id="_3-2-没有把错误抛出到外层" tabindex="-1"><a class="header-anchor" href="#_3-2-没有把错误抛出到外层" aria-hidden="true">#</a> 3.2 没有把错误抛出到外层</h4><p>外层事务控制不知道发生异常</p><h4 id="_3-3-aop切面顺序-around包裹后-如果-around没有把异常抛出-会有异常" tabindex="-1"><a class="header-anchor" href="#_3-3-aop切面顺序-around包裹后-如果-around没有把异常抛出-会有异常" aria-hidden="true">#</a> 3.3 aop切面顺序 @Around包裹后 如果@Around没有把异常抛出 会有异常</h4><p>调整切面的@Order</p><p>切面类抛出异常</p><h4 id="_3-4-transactional-加在了非public-方法上" tabindex="-1"><a class="header-anchor" href="#_3-4-transactional-加在了非public-方法上" aria-hidden="true">#</a> 3.4 @transactional 加在了非public 方法上</h4><h4 id="_3-5-父子容器导致失效" tabindex="-1"><a class="header-anchor" href="#_3-5-父子容器导致失效" aria-hidden="true">#</a> 3.5 父子容器导致失效</h4><p>子容器扫描范围过大 如果找不到 会往父容器去找 子容器有 不回去拿父容器的</p><h4 id="_3-6-在一个方法内调另一个方法时-不会走代理-导致事务失效" tabindex="-1"><a class="header-anchor" href="#_3-6-在一个方法内调另一个方法时-不会走代理-导致事务失效" aria-hidden="true">#</a> 3.6 在一个方法内调另一个方法时 不会走代理 导致事务失效</h4><p>把proxy注入依赖 通过proxy调另外一个方法</p><h4 id="_3-7-多线程无法保证原子性" tabindex="-1"><a class="header-anchor" href="#_3-7-多线程无法保证原子性" aria-hidden="true">#</a> 3.7 多线程无法保证原子性</h4><p>synchronized范围太小 没有覆盖commit</p><p>没包括代理的问题</p><p>可以在数据库的层面做控制 for update</p><h2 id="_4-springmvc执行流程" tabindex="-1"><a class="header-anchor" href="#_4-springmvc执行流程" aria-hidden="true">#</a> 4.SpringMVC执行流程</h2><figure><img src="'+l+'" alt="image-20220825145442932" tabindex="0" loading="lazy"><figcaption>image-20220825145442932</figcaption></figure><figure><img src="'+d+'" alt="image-20220825145537481" tabindex="0" loading="lazy"><figcaption>image-20220825145537481</figcaption></figure><figure><img src="'+h+'" alt="image-20220825145655091" tabindex="0" loading="lazy"><figcaption>image-20220825145655091</figcaption></figure><h2 id="_5-spring常见注解" tabindex="-1"><a class="header-anchor" href="#_5-spring常见注解" aria-hidden="true">#</a> 5.Spring常见注解</h2><ul><li><p>lang</p><ul><li><p>@nonnull</p></li><li><p>@nonnullapi</p></li><li><p>@nonnullfields</p></li><li><p>@nullable</p></li><li><p>@usessunmisc</p></li></ul></li><li><p>事务</p><ul><li><p>@EnabletransactionManagement：启用声明式管理</p></li><li><p>@transactional: public类的方法是受事务控制类的公共方法受到控制</p></li></ul></li><li><p>核心</p><ul><li><p>@aliasFor：别名</p></li><li><p>@Order：bean执行的顺序、数字越小优先级越高</p></li></ul></li><li><p>切面</p><ul><li>@EnableAspectJAutoProxy：启用AOP自动代理</li></ul></li><li><p>组件扫描和配置类</p><ul><li><p>@Component：标注了的类 被纳入spring容器管理</p></li><li><p>@Controller：</p></li><li><p>@Service：</p></li><li><p>@Repository：</p></li><li><p>@Indexed：</p></li><li><p>@ComponentScan：进行扫描的包</p></li><li><p>@Conditional：组件扫描做条件装配 符合条件加入</p></li><li><p>@Configuration：加配置类 其实是一个工厂</p></li><li><p>@DependsOn：无明显依赖关系的bean的实例化优先级</p></li><li><p>@Description</p></li><li><p>@Bean：标注配置类的方法作为Bean的定义 其实是工厂里的工厂方法</p></li><li><p>@Import：导入其他的配置类 或其他的selector</p></li><li><p>@Lazy：标注在类上 表示是延时实例化初始化 ；加在成员变量 方法参数 解决循环依赖 注入推迟进行</p></li><li><p>@PropertySource：读取外部的键值对文件</p></li></ul></li><li><p>依赖注入</p><ul><li><p>@Autowired：依赖注入</p></li><li><p>@Qualifier：同一个Bean有多个名字 用来区分</p></li><li><p>@Value：解释值</p></li><li><p>@Lookup：</p></li></ul></li><li><p>mapping</p><ul><li>@RequestMapping：请求的路径与控制器的路径的键值关系</li><li>@GetMapping：请求方式只能为get</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li><li>@PatchMapping</li><li>@Mapping</li></ul></li><li><p>rest</p><ul><li><p>@RequestBody：处理json数据转为java对象</p></li><li><p>@ResponseStatus:处理java对象转换为json</p></li><li><p>@ResponseStatus：响应的状态</p></li><li><p>@RestController：</p></li></ul></li><li><p>统一处理</p><ul><li><p>ControllerAdvice：统一处理的异常放进去</p></li><li><p>ExceptionHandler：处理异常</p></li></ul></li><li><p>参数</p><ul><li><p>@PathVariable：获取请求路径中的参数</p></li><li><p>@RequestHeader:请求头参数值</p></li><li><p>@RequestParam：请求参数</p></li><li><p>@CookieValue</p></li></ul></li><li><p>转换</p><ul><li>datetimeformat 日期</li></ul></li><li><p>validation</p><ul><li>@validation</li></ul></li><li><p>ajax</p><ul><li>@CrossOrigin：解决ajax跨域问题</li></ul></li><li><p>boot</p><ul><li><p>properties</p><ul><li><p>@ConfigurationProperties</p></li><li><p>@EnableConfigurationProperties</p></li></ul></li><li><p>auto</p><ul><li>@SpringBootApplication</li><li>@EnableAutoConfiguration:自动配置类的东西都加进来</li><li>@</li></ul></li><li><p>condition</p><ul><li>@ConditionOnClass：只有内部包含该类的时候 条件就成立 执行后续装配</li><li>@ConditionOnMissingBean：缺失某个bean的时候 条件成立</li><li>@ConditionalOnproperty：根据键值信息 看是否一样 条件成立</li></ul></li><li><p>其它</p><ul><li>@EnableConfigurationProperties</li><li>@ConfigurationProperties</li></ul></li></ul></li></ul><p>​</p><h3 id="深入理解-configuration" tabindex="-1"><a class="header-anchor" href="#深入理解-configuration" aria-hidden="true">#</a> 深入理解@Configuration</h3><p>配置类其实相当于一个工厂 标注@bean相当于工厂方法</p><p>@Bean 不支持方法重载 如果有多个 只能有一个工厂方法 保证@Bean的单例特性</p><p>@Configuration会为标注的类生成代理 保证@Bean相互调用时 保证单例特性</p><p>bean工厂后处理器配置在config中时 会导致config类提前创建 而解析成员变量的bean后处理器还没有加载 所以会导致@Value解析失败</p><p>解决方法 把beanFactoryPostProcessor设置为static 不要用成员变量 而是作为方法的局部变量</p><p>@Import先解析 @Bean后解析 如果有同名 会覆盖前面的</p><h3 id="理解-springbootapplication" tabindex="-1"><a class="header-anchor" href="#理解-springbootapplication" aria-hidden="true">#</a> 理解@SpringBootApplication</h3><p>@SpringBootConfiguration：只有一个配置类</p><p>@ComponentScan</p><p>@EnableAutoConfiguration</p><h2 id="_6-spring中的设计模式" tabindex="-1"><a class="header-anchor" href="#_6-spring中的设计模式" aria-hidden="true">#</a> 6.Spring中的设计模式</h2><h3 id="_6-1单例模式" tabindex="-1"><a class="header-anchor" href="#_6-1单例模式" aria-hidden="true">#</a> 6.1单例模式</h3><p>singletonbean并非单例模式</p><h3 id="_6-2建造器模式" tabindex="-1"><a class="header-anchor" href="#_6-2建造器模式" aria-hidden="true">#</a> 6.2建造器模式</h3><p>链式调用</p><p>beandefinitionbuilder</p><p>headersbuilder</p><h3 id="_6-3-工厂方法模式" tabindex="-1"><a class="header-anchor" href="#_6-3-工厂方法模式" aria-hidden="true">#</a> 6.3 工厂方法模式</h3><p>降低耦合</p><p>getbean工厂方法 隐藏了产品的创建过程</p><h3 id="_6-4-adapter适配器模式" tabindex="-1"><a class="header-anchor" href="#_6-4-adapter适配器模式" aria-hidden="true">#</a> 6.4 adapter适配器模式</h3><p>handleradapter</p><p>控制器实现多种多样 调用时统一成handleadapter 统一调用</p><p>销毁bean的时候 disposablebeanadapter 销毁方法适配为 disposablebean 统一销毁</p><h3 id="_6-5composite组合模式" tabindex="-1"><a class="header-anchor" href="#_6-5composite组合模式" aria-hidden="true">#</a> 6.5composite组合模式</h3><p>将分散的调用集中起来 统一调用入口 交给具体的实现取做事</p><h3 id="_6-6-decorator-装饰器模式" tabindex="-1"><a class="header-anchor" href="#_6-6-decorator-装饰器模式" aria-hidden="true">#</a> 6.6.decorator 装饰器模式</h3><p>注重功能增强</p><h3 id="_6-7代理模式" tabindex="-1"><a class="header-anchor" href="#_6-7代理模式" aria-hidden="true">#</a> 6.7代理模式</h3><p>注重控制目标的访问</p><p>jdkdynamicapoproxy</p><p>objenesiscglibaopproxy</p><h3 id="_6-8责任链模式" tabindex="-1"><a class="header-anchor" href="#_6-8责任链模式" aria-hidden="true">#</a> 6.8责任链模式</h3><p>对多个请求对象串成链 依次请求 直到遇到可以</p><p>handlerinterceptor 拦截器</p><h3 id="_6-9观察者模式" tabindex="-1"><a class="header-anchor" href="#_6-9观察者模式" aria-hidden="true">#</a> 6.9观察者模式</h3><p>事件的实现</p><h3 id="_6-10-strategy-策略模式" tabindex="-1"><a class="header-anchor" href="#_6-10-strategy-策略模式" aria-hidden="true">#</a> 6.10 strategy 策略模式</h3><p>提供多种策略方式 父子容器搜索策略等</p><p>实例化策略</p><h3 id="_6-11-模板模式" tabindex="-1"><a class="header-anchor" href="#_6-11-模板模式" aria-hidden="true">#</a> 6.11 模板模式</h3><p>bean的生命流程</p><p>jdbc模板</p><p>transaction模板</p><h2 id="_7-循环依赖解决方式" tabindex="-1"><a class="header-anchor" href="#_7-循环依赖解决方式" aria-hidden="true">#</a> 7.循环依赖解决方式</h2>',193),g=[u];function b(f,_){return a(),i("div",null,g)}const x=e(c,[["render",b],["__file","Springinterview.html.vue"]]);export{x as default};
