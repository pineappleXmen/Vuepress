const e=JSON.parse('{"key":"v-450f9a85","path":"/article/javastack/javaadvance/thread.html","title":"Chapter 17. Threads and Locks","lang":"zh-CN","frontmatter":{"description":"Chapter 17. Threads and Locks While most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single thread, the Java Virtual Machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time-slicing many hardware processors.","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/article/javastack/javaadvance/thread.html"}],["meta",{"property":"og:site_name","content":"Pineapple Coding"}],["meta",{"property":"og:title","content":"Chapter 17. Threads and Locks"}],["meta",{"property":"og:description","content":"Chapter 17. Threads and Locks While most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single thread, the Java Virtual Machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time-slicing many hardware processors."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"headers":[{"level":2,"title":"17.1. Synchronization","slug":"_17-1-synchronization","link":"#_17-1-synchronization","children":[]},{"level":2,"title":"17.2. Wait Sets and Notification","slug":"_17-2-wait-sets-and-notification","link":"#_17-2-wait-sets-and-notification","children":[{"level":3,"title":"17.2.1. Wait","slug":"_17-2-1-wait","link":"#_17-2-1-wait","children":[]},{"level":3,"title":"17.2.2. Notification","slug":"_17-2-2-notification","link":"#_17-2-2-notification","children":[]},{"level":3,"title":"17.2.3. Interruptions","slug":"_17-2-3-interruptions","link":"#_17-2-3-interruptions","children":[]},{"level":3,"title":"17.2.4. Interactions of Waits, Notification, and Interruption","slug":"_17-2-4-interactions-of-waits-notification-and-interruption","link":"#_17-2-4-interactions-of-waits-notification-and-interruption","children":[]}]},{"level":2,"title":"17.3. Sleep and Yield","slug":"_17-3-sleep-and-yield","link":"#_17-3-sleep-and-yield","children":[]},{"level":2,"title":"17.4. Memory Model","slug":"_17-4-memory-model","link":"#_17-4-memory-model","children":[{"level":3,"title":"17.4.1. Shared Variables","slug":"_17-4-1-shared-variables","link":"#_17-4-1-shared-variables","children":[]},{"level":3,"title":"17.4.2. Actions","slug":"_17-4-2-actions","link":"#_17-4-2-actions","children":[]},{"level":3,"title":"17.4.3. Programs and Program Order","slug":"_17-4-3-programs-and-program-order","link":"#_17-4-3-programs-and-program-order","children":[]},{"level":3,"title":"17.4.4. Synchronization Order","slug":"_17-4-4-synchronization-order","link":"#_17-4-4-synchronization-order","children":[]},{"level":3,"title":"17.4.5. Happens-before Order","slug":"_17-4-5-happens-before-order","link":"#_17-4-5-happens-before-order","children":[]},{"level":3,"title":"17.4.6. Executions","slug":"_17-4-6-executions","link":"#_17-4-6-executions","children":[]},{"level":3,"title":"17.4.7. Well-Formed Executions","slug":"_17-4-7-well-formed-executions","link":"#_17-4-7-well-formed-executions","children":[]},{"level":3,"title":"17.4.8. Executions and Causality Requirements","slug":"_17-4-8-executions-and-causality-requirements","link":"#_17-4-8-executions-and-causality-requirements","children":[]},{"level":3,"title":"17.4.9. Observable Behavior and Nonterminating Executions","slug":"_17-4-9-observable-behavior-and-nonterminating-executions","link":"#_17-4-9-observable-behavior-and-nonterminating-executions","children":[]}]},{"level":2,"title":"17.5. final Field Semantics","slug":"_17-5-final-field-semantics","link":"#_17-5-final-field-semantics","children":[{"level":3,"title":"17.5.1. Semantics of final Fields","slug":"_17-5-1-semantics-of-final-fields","link":"#_17-5-1-semantics-of-final-fields","children":[]},{"level":3,"title":"17.5.2. Reading final Fields During Construction","slug":"_17-5-2-reading-final-fields-during-construction","link":"#_17-5-2-reading-final-fields-during-construction","children":[]},{"level":3,"title":"17.5.3. Subsequent Modification of final Fields","slug":"_17-5-3-subsequent-modification-of-final-fields","link":"#_17-5-3-subsequent-modification-of-final-fields","children":[]},{"level":3,"title":"17.5.4. Write-Protected Fields","slug":"_17-5-4-write-protected-fields","link":"#_17-5-4-write-protected-fields","children":[]}]},{"level":2,"title":"17.6. Word Tearing","slug":"_17-6-word-tearing","link":"#_17-6-word-tearing","children":[]},{"level":2,"title":"17.7. Non-Atomic Treatment of double and long","slug":"_17-7-non-atomic-treatment-of-double-and-long","link":"#_17-7-non-atomic-treatment-of-double-and-long","children":[]}],"git":{},"readingTime":{"minutes":35.2,"words":10559},"filePathRelative":"article/javastack/javaadvance/thread.md","excerpt":"<h1> Chapter 17. Threads and Locks</h1>\\n<p>While most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single <em>thread</em>, the Java Virtual Machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time-slicing many hardware processors.</p>","autoDesc":true}');export{e as data};
